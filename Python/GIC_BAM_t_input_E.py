# -*- coding: utf-8 -*-
"""
Property: Observatori de l'Ebre. Author: Santiago Marsal Vinadé & Jordi Gómez Jodar.
License: GNU General Public License 3 (GPL-3.0) (http://opensource.org/licenses/GPL-3.0)

Construction of a DC-equivalent network and GIC computation over time in a power network by means of the Bus Admittance Matrix (BAM).
Input:
 - Real network parameters (line and grounding resistances, transformer types and winding resistances, substation locations, ...) conveniently arranged in input Excel file. Assumed constant in time.
 - Geoelectric field over time. It may be either homogeneous (constant in space) or heterogeneous (variable in space). If heterogeneous, the E field is given in a grid covering the power network area. The E field along the power network is interpolated from this grid.
     Note: Heterogeneous E-fields are assumed to have been generated by other means (e.g., from magnetic field and earth conductivity data).
Output:
 - Ig: GIC flow to earth in substation earthing over time,
 - Ilinph: GIC flow per phase in each transmission line over time.
 - Iwi: GIC flow in transformer windings (/phase) over time.
 - It: effective GIC flow in transformers (/phase) over time.
 
Abbreviations used:
    nt -> number of time steps.
    NumGridP -> number of grid points where the E field is given.
    nTF -> Number of transformers in the power grid.
    n -> Number of transmission lines in power grid.
"""
import numpy as np # Basic math library.

import matplotlib.pyplot as plt # Plotting library.
import cv2 # Video library.

import pandas as pd # Read Excel library.
from openpyxl import load_workbook # Library that allows writing on Excel sheets.

# Scipy: Library with more specific math functions.
from scipy import sparse # Module that allows to create sparse functions.
import scipy.sparse.linalg # Module to be called apart to linearly operate sparse matrices.
import scipy.interpolate # Interpolation module.

import time # Execution time computation library.
import datetime as dati # Date and time managing
from datetime import datetime # Date and time managing

#%% User-defined parameters, open input file and read-in data.
start = time.time()

"""
Start input parameters:
"""
# Input Excel file name. Contains the power network information:
filename = "BenchmarkGrid.xlsx"
#filename = 'Horton&BotelerGrid.xlsx'
#filename = 'TstGrid_a.xlsx'
#filename = 'TstGrid_b.xlsx'

WriteEqNetXLS = 0 # If 1, writes equivalent network in the input Excel file (creates new 'NodesEq' and 'LinesEq' sheets); otherwise, 0. Warning: writing in Excel slows down the process.
E_homo_hetero = 1 # 1 for a homogeneous (constant in space) E field; otherwise heterogeneous.

if E_homo_hetero == 1: # Homogeneous E field over time [t1, tn]
    # User-defined homogeneous E field over time: E = [E_E(t), E_N(t)] 1st column is for the east component over time; 2nd is for the northward component. [V/km] (nt x 2)

    E  = np.array([0, 1]) # East, North E field at time t1
    E2 = np.array([1, 0]) # East, North E field at time t2
    E3 = np.array([1, 1]) # East, North E field at time t3
    # ...
    #En = np.array([E_En, E_Nn]) # East and North E field at time tn
    
    E = np.stack([E, E2, E3]) # Stacking through time.
else: # Heterogeneous E field over time [t1, tn]
    da = 0.1 # Step angle to make the integral of the path along each line. [º]
    # Text files containing the E field in a grid. One component (East and North) per file.
    fileE_E = 'E_2D_East.txt' # Comma-separated values of the East component of the E field. The file contains one row per time step and one column per grid point. [V/km] (nt x NumGridP)
    fileE_N = 'E_2D_North.txt' # Comma-separated values of the North component of the E field. The file contains one row per time step and one column per grid point. [V/km] (nt x NumGridP)
    fileEgrid = 'LatLon_Egrid_SE_USA.txt' # Comma-separated values with Latitude, Longitude (in decimal degrees) of each grid point. (NumGridP x 2)
     #fileEgrid = 'LatLon_MT.txt' # Comma-separated values with Latitude, Longitude (in decimal degrees) of each grid point. (NumGridP x 2)
    
ShowFigures = 1 # 1 to show figures; 0 otherwise
if ShowFigures == 1:
    BaseMapFile = 'LatLon_SE_USA.txt' # Name of the base map file typically containing coordinates of the coastlines. If empty ('') no base map is loaded.
    BaseMapFileDataType = 1 # if 1 the data of the BaseMapFile are given in Lat, Lon format; otherwise, data are given in UTM coordinates.
    ForceUTMZoneTo = 16 # Force UTM zone to this value for representation purposes. E.g.: 9-20 for USA, 30 for Spain, ... See, e.g., https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system
    Check_Extrap = 0 # 1 shows map of off-grid substations and corresponding extrapolated E field for a user-defined time.
    SaveVideoAs = 'Ig_Benchmark' # Name of the video (.avi) to be saved, showing grounding GIC (Ig) through time. If empty ('') no video is generated. E.g.: 'MyVideo'.
    if not len(SaveVideoAs) == 0: # Applies for non-empty video name.
        datetime_video_start = "2022-11-14 23:41" # Date & time for the initial video frame. See tIniVideo and tFinVideo variables below.
"""
End input parameters.
"""

print(filename)

if E_homo_hetero == 1:
        Check_Extrap = 0 # 1 shows map of outsider substations and corresponding extrapolated E field for a user-defined time.
        
Xsubstations = pd.read_excel(filename,sheet_name='Substations') # Reading in 'Substatins' Excel sheet.
Xlines = pd.read_excel(filename,sheet_name='Lines') # Reading in 'Lines' Excel sheet.

row_subs = Xsubstations.shape[0] # Number of rows of Substations sheet.
col_subs = Xsubstations.shape[1] # Number of columns of Substations sheet.

# Checking that the content of the Excel data is OK; if not, release warning:
if col_subs > 12:
    raise ValueError('Too many numerical columns in ''Substations'' sheet. Please, make sure all rows in the first column are text cells and there is no further information in the sheet other than required.')
if col_subs < 11:
    raise ValueError('Not enough numerical columns in ''Substations'' sheet. Please, make sure the entered information is complete.')
if col_subs == 11:
    print('Adding the LV bus column') # Complete last column of 'Substations' sheet in case it is empty (case of a single voltage level).
    add_nan_array = np.ones((row_subs))*float('nan')
    Xsubstations.insert(11,'LV bus (kVAC)',add_nan_array)

len_lines = Xlines.shape[1]

if len_lines < 6 or len_lines > 6:
    raise ValueError('Incorrect number of numerical columns in ''Lines'' sheet. Should be 6. Please, make sure the entered information is complete and there are no exceeding columns.')

m = len(Xsubstations[~Xsubstations.iloc[:,0].isnull()].iloc[:,0]) # Number of substations.
nTF = int(sum(Xsubstations[~Xsubstations.iloc[:,5].isnull()].iloc[:,5])) # Number of transformers.
n = Xlines[~Xlines.iloc[:,0].isnull()].shape[0] # nº of transmission lines in the network (repeated transmission lines, i.e., with the same resistance between the same 2 buses are counted as 1, so nº of transects indeed).
n_nan = Xsubstations.iloc[:,1].isnull().to_numpy()*1 

 # Controls:
for col in [2, 3, 5]:
    new_nan = Xsubstations.iloc[:,col].isnull().to_numpy()*1 
    if not (n_nan == new_nan).all():
        raise ValueError('Columns 3, 4 and 6 should have the same non-empty rows as column 2')

if not row_subs == nTF:
    raise ValueError('The number of transformers (column 6) should be consistent with the number of rows of ''Substations'' sheet.')

n_order = Xsubstations[~Xsubstations.iloc[:,1].isnull()].iloc[:,1]
n_order = n_order.to_numpy()

if not (n_order == np.arange(1,m+1)).all():
    raise ValueError('Substation numbers should be consecutive from 1 to m (number of substations).')

if (Xlines.iloc[:,5].isnull() == True).any():
    raise ValueError('Line voltage [kVAC] (column 6 of ''Lines'' sheet) cannot be empty.')

#Data read in 'Substations' sheet:
RowsSubs = Xsubstations[~Xsubstations.iloc[:,2].isnull()]
LatLonSubs = RowsSubs.iloc[:,2:4].to_numpy() # Substation latitude and longitude. (m x 2) [º]
RgSubs = RowsSubs.iloc[:,4].to_numpy() # Substation earthing resistances. (m x 1) [ohm]
nTFSubs = RowsSubs.iloc[:,5].to_numpy() # nº of transformers in each substation. (m x 1) []
TxtRefTF = Xsubstations.iloc[0:row_subs,6].to_list() # Transformer reference. (n x 1) [text]
RphW1STF = Xsubstations.iloc[:,7].to_numpy() # Transformer primary/series winding resistance per phase. (nTF x 1) [ohm/ph]
RphW2CTF = Xsubstations.iloc[:,8].to_numpy() # Transformer secondary/common winding resistance per phase. (nTF x 1) [ohm/ph]
TFtypeTF = Xsubstations.iloc[0:row_subs,9].to_list() # Transformer type. (nTF x 1) [text]
HVBusTF = Xsubstations.iloc[:,10].to_numpy() # Transformer high-voltage bus. (nTF x 1) [kVAC]
LVBusTF = Xsubstations.iloc[:,11].to_numpy() # Transformer low-voltage bus. (nTF x 1) [kVAC]
# Data read in 'Lines' sheet:
OriSubsLin = Xlines.iloc[:,0].to_numpy() # Transmission line origin substation. (n x 1) []
DesSubsLin = Xlines.iloc[:,1].to_numpy() # Transmission line destination substation. (n x 1) []
RphLin = Xlines.iloc[:,2].to_numpy() # Transmission line resistance per phase. (n x 1) [ohm/ph]
nrepLin = Xlines.iloc[:,3].to_numpy() # Number of repetitions of each transmission line. (n x 1) []
VTLin = Xlines.iloc[:,5].to_numpy() # AC voltage of each transmission line. (n x 1) [kVAC]

# Once parameters read in, construct the DC-equivalent network in separate cell
#%% ConsEqNet: constructs a DC-equivalent network from sheets 'Substations' and 'Lines' of the defined input Excel file.

eps = 1e-6

if np.isnan(HVBusTF).any():
    raise ValueError('All transformers should have a HV value (column 11 of ''Substations'' sheet.)')

VLTF = np.dstack((HVBusTF,LVBusTF)) # High and low voltage levels of each transformer (nTF x 2) [kVAC]

VLSubs = np.full((int(2*nTFSubs.max()),m), np.nan) #Will contain the sorted voltage levels at each substation (L x m) [kVAC].

for Subs in range(0,m): #Loop through substations to set the sorted voltage levels at each substation
    RowsCurSubs = RowsSubs.index[Subs]# Rows in 'Substations' sheet corresponding to the current substation (excluding header).
    VLTFSubs = np.unique(VLTF[:,RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])])
    VLTFSubs = VLTFSubs[~np.isnan(VLTFSubs)]
    VLTFSubs = VLTFSubs.flatten()
    VLSubs[0:len(VLTFSubs),Subs]=np.flipud(VLTFSubs) #Voltage levels found at current substation [kVAC].

l = sum(~np.isnan(VLSubs)) #Nº of voltage levels providing a path for GIC in each substation (1 x m).
L = np.max(l) #Maximum nº of voltage levels in a single substation. This is the allocated number of buses in each substation of the model.
VLSubs = VLSubs[0:L,:] #Sorted (descending order) voltage levels at each substation (L x m) [kVAC].
nNodCon = L*(L + 1)/2 #Nº of possible connections between nodes of the same substation.
ntot = n + nNodCon*m #Total nº of branches (real TLs + subs. internal branches) in the DC-equivalent network.
nNod = m*(L + 1) #Total nº of nodes in the equivalent network.
nBBCon = L*(L - 1)/2 #nº of possible connections between buses of the same substation.


LinesEq = np.full((int(ntot),8), np.nan) #(ntot x 8)
LinesEq[0:n,2] = RphLin[0:n]
LinesEq[0:n,3] = nrepLin[0:n]
LinesEq[0:n,5] = VTLin[0:n]
LinesEq[0:n,6] = OriSubsLin[0:n]
LinesEq[0:n,7] = DesSubsLin[0:n]

for tlin in range(0,n): #Loop through (real) transmission lines to set their origin and destination nodes in the equivalent network.
    VLin = VTLin[tlin] #Line voltage [kVAC].
    SubsLineOri = OriSubsLin[tlin]
    SubsLineDes = DesSubsLin[tlin] # Nº of the substation where the current line starts and nº of the substation where the current line ends.
    if not any(VLSubs[:,SubsLineOri-1] == VLin):
        raise ValueError('Voltage of line nº ', str(SubsLineOri), ' (according to ''Lines'' sheet) not found among voltages of its origin substation (according to ''Substations'' sheet). File error')
    if not any(VLSubs[:,SubsLineDes-1] == VLin):
        raise ValueError('Voltage of line nº ', str(tlin), ' (according to ''Lines'' sheet) not found among voltages of its destination substation (according to ''Substations'' sheet). File Error')
    LinesEq[tlin,0] = m*(np.argwhere(VLSubs[:,SubsLineOri-1] == VLin)+1)+SubsLineOri
    LinesEq[tlin,1] = m*(np.argwhere(VLSubs[:,SubsLineDes-1] == VLin)+1)+SubsLineDes #Origin and destination nodes of transmission lines.

"""
Generate new nodes in NodesEq array, namely, L + 1 nodes per real substation:
1st node corresponds to substation neutral point (NP).
2nd node corresponds to highest AC voltage level bus (b1) found in substation.
(l(Subs) + 1)-th node corresponds to lowest AC voltage level bus (bl) found in substation.
(l(Subs) + 2)-th node corresponds to the first "vitrual" bus.
(L + 1)-th node corresponds to the last "virtual" bus.
"""
NodesEq = np.full((nNod, 7),np.nan) #Will contain numerical info about the nodes of the equivalent network. (nNod x 7)

RgSubs[RgSubs == 0] = eps 
transVLSubs = np.transpose(VLSubs)
NodesEq[:,1] = np.transpose(np.arange(1,nNod+1))
LatLonRg = np.hstack((LatLonSubs,RgSubs[:,None]))
LatLonRg = np.tile(LatLonRg,(L+1,1))
NodesEq[:,2] = LatLonRg[:,0]
NodesEq[:,3] = LatLonRg[:,1]
NodesEq[:,4] = LatLonRg[:,2]
NodesEq[:,6] = np.concatenate((np.full((m,1),np.nan),transVLSubs.flatten('A')),axis=None)
NodesEq[m + 1: NodesEq.shape[0], 4] = np.nan

Sub_Ref = [None]*NodesEq.shape[0]
for jj in range(0,m):
    Sub_Ref[jj] = 'np_Sub'+str(int(NodesEq[jj,1]))
    for ii in range(0,L):
        Sub_Ref[m*(ii+1)+jj] = "b"+str(ii+1)+"_Sub"+str(int(NodesEq[jj,1]))
        
#Resistance of HV (GSU, GY-GY) or series (A) winding of each transformer. (nTF x 1) [ohm/ph]:
RphW1STF[RphW1STF == 0] = eps
RphW1Sinv = 1/RphW1STF
RphW1Sinv[np.isnan(RphW1Sinv)] = 0

#Resistance of LV (GSU, GY-GY) or common (A) winding of each transformer. (nTF x 1) [ohm/ph]
RphW2CTF[RphW2CTF == 0] = eps
RphW2Cinv = 1/RphW2CTF
RphW2Cinv[np.isnan(RphW2Cinv)] = 0

IsATall = []
IsTeeall = []
for kk in range(0,nTF):
    IsATall.append(('A' == TFtypeTF[kk])*1) #1 for autotransformers; 0 otherwise. (nTF x 1)
    IsTeeall.append(('T' == TFtypeTF[kk])*1) #1 for Tee substations; 0 otherwise. (nTF x 1)

Trafo_Ref = [None]*NodesEq.shape[0]

for Subs in range(0,m):
    RowsCurSubs = RowsSubs.index[Subs] #Rows in 'Substations' sheet corresponding to the current substation (excluding header).
    
    Reqbn = np.full((L,1),np.nan) #Will contain the equivalent resistance of bus-neutral connections (primary, secondary and common winding resistances of transformers). [ohm] (L x 1)
    ReqSer = np.full((int(nBBCon), 1),np.nan) #Will contain the equivalent resistance of bus-bus connections within substation (series winding resistances of autotransformers). [ohm] (nBBCon x 1)
    
    HVBus = HVBusTF[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] #HV bus of the transformers in current substation [kVAC]. Cannot be blank. (nTFSubs(Subs) x 1)
    LVBus = LVBusTF[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] #LV bus of the transformers in current substation [kVAC]. Can be blank (e.g. for delta windings, which are not earthed, and tee's). (nTFSubs(Subs) x 1)
    
    IsATSubs = IsATall[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] #1 for autotransformers; 0 otherwise. (nTFSubs(Subs) x 1)

    if np.isnan(HVBus[0:int(nTFSubs[Subs])] + LVBus[0:int(nTFSubs[Subs])]).any() and (IsATSubs[0:int(nTFSubs[Subs])]==1):
        raise ValueError('Bus voltages cannot be empty for an autotransformer. Revise columns 11 and 12 of substation ', str(Subs), ' in ''Substations'' sheet.')

    IsTeeSubs = IsTeeall[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] #1 for Tee's; 0 otherwise. (nTFSubs(Subs) x 1)
    RphW1SinvSubs = RphW1Sinv[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] #Reciprocal resistance of transformern windings. [ohm^-1] (nTFSubs(Subs) x 1)
    RphW2CinvSubs = RphW2Cinv[RowsCurSubs:RowsCurSubs+int(nTFSubs[Subs])] 

    CountConNod = np.zeros(4,dtype=int)
    for i in range(0,L+1): #Loop through the L + 1 nodes of each substation.
        CountConNod = CountConNod[L-i] + np.arange(1,L+1-i) 
        #Nº of connections between node i and the other nodes of the same substation.
        if not i == L:
            #Origin node
            LinesEq[n+int(nNodCon*(Subs))+CountConNod-1,0] = np.tile(i*m+Subs+1,(L-i,1))[0,:]
            
            #Destination node
            LinesEq[n+int(nNodCon*(Subs))+CountConNod-1,1] = np.transpose(m*np.arange(i + 1, L+1)) + Subs+1
            
            #Origin substation
            LinesEq[n+int(nNodCon*(Subs))+CountConNod-1,6] = np.tile(Subs+1,(2,L-i))[0,:]
            
            #Destination substation
            LinesEq[n+int(nNodCon*(Subs))+CountConNod-1,7] = np.tile(Subs+1,(2,L-i))[1,:]
        TxtRefTrafos = ""
        for tf in range(0,int(nTFSubs[Subs])):
            if i <= l[Subs] and (i<=1 or (VLSubs[i-1,Subs]==[HVBus[tf],LVBus[tf]]).any()):
                TxtRefTrafos = TxtRefTrafos + TxtRefTF[RowsSubs.index[Subs] + tf] + ", " #Trafo reference text corresponding to the substation associated with each node (to track original transformers).      

        Trafo_Ref[i*m+Subs]=TxtRefTrafos  #Write transformer reference text in NodesEq array.
        if i > 0 and i <=l[Subs]:
            Denominator_Req = sum(RphW1SinvSubs[(HVBus==VLSubs[i-1, Subs]) * (np.logical_not(list(map(bool,IsATSubs))))])+sum(RphW2CinvSubs[LVBus==VLSubs[i-1,Subs]])
            
            if Denominator_Req == 0:
                Reqbn[i-1] = np.inf
            else:
                Reqbn[i-1] = 1/Denominator_Req
            
            if any(IsTeeSubs) == 1: #Tee substations
                if nTFSubs[Subs] > 1:
                    raise ValueError('Tee substations should contain a unique row in ''Substations'' sheet, i.e., no other transformers are allowed. Revise substation nº ', str(Subs), '.', 'File error')
                if any([np.isnan(RgSubs[Subs]),np.isnan(LVBus)])==False:
                    raise ValueError('LV bus (column 12) and Re (column 5) should be empty cells in a Tee substation. Revise substation nº ', str(Subs), ' in ''Substations'' sheet.', 'File error')
                
            LinesEq[n + int(nNodCon*(Subs)) + (i-1),2] = Reqbn[i-1] #Equivalent bus-neutral resistance of the branches joining the L buses with the np at a given substation. [ohm] (L x 1)
            
            for j in range(i,l[Subs]):
                BBCon = L*(i-1) - (i)*(i + 1)/2 + j +1 #Bus-bus connection. Note: the final '+1' must be added as Python loops range from 0 to max - 1.

                #Equivalent resistance of bus-bus connections within substation (series winding resistances of autotransformers). [ohm] (nBBCon x 1)
                Denominator_ReqSer = sum(RphW1SinvSubs[(HVBus==VLSubs[i-1, Subs])*(LVBus == VLSubs[j, Subs])*(list(map(bool,IsATSubs)))])
                if Denominator_ReqSer == 0:
                    ReqSer[int(BBCon-1)] = np.inf
                else:
                    ReqSer[int(BBCon-1)] = 1/Denominator_ReqSer
                
                LinesEq[n + int(nNodCon*(Subs)) + L + int(BBCon-1), 2] = ReqSer[int(BBCon-1)] # Equivalent bus-bus series resistance of the branches joining the L buses of a given substation. [ohm] (nBBCon x 1)

    # If there's no way to ground in substation, allocate a finite grounding resistance while keeping infinite bus-neutral resistances:
    if all(~np.isfinite(LinesEq[n + int(nNodCon*(Subs)) + np.arange(0,L),2]))== True:
        if ~np.isfinite(NodesEq[Subs,4])==True:
            NodesEq[Subs,4] = 0.10012

LinesEq[n:,3] = 1
LinesEq[:,4] = LinesEq[:,2]/3./np.concatenate((nrepLin,np.ones((int(ntot-n)),dtype=np.int64)))
LinesEq[~np.isfinite(LinesEq)] = np.nan

# Write NodesEq and LinesEq arrays in Excel file if required:
if WriteEqNetXLS == 1:
    NodesEqTxt = pd.DataFrame(NodesEq)
    NodesEqTxt.columns = ['Node', 'Nº', 'Latitude (°)', 'Longitude (°)', 'Rg (ohm)', 'Trafo ref.', 'Bus voltage (kVAC)']
    NodesEqTxt.iloc[:,0] = Sub_Ref
    NodesEqTxt.iloc[:,1:4] = NodesEq[:,1:4]
    NodesEqTxt.iloc[:,5] = Trafo_Ref
    NodesEqTxt.iloc[:,6] = NodesEq[:,6]
    LinesEqTxt = pd.DataFrame(LinesEq, columns = ['Origin node #', 'Destination node #', 'Resistance (ohm/ph)', 'Nº lines', 'Total line resistance (ohm)', 'Line voltage (kVAC)', 'Origin subs #', 'Destination subs #'])
    
    book = load_workbook(filename)
    writer = pd.ExcelWriter(filename, engine='openpyxl') 
    writer.book = book
    writer.sheets = dict((ws.title, ws) for ws in book.worksheets)
    
    NodesEqTxt.to_excel(writer,sheet_name = 'NodesEq',index = False)
    LinesEqTxt.to_excel(writer,sheet_name = 'LinesEq',index = False)
    
    writer.save()
#%% Functions:

def deg2utm_zone(Lt, Ln, ZoneNumber): # Converts from Lat, Lon to UTM coordinates with a pre-established UTM zone. 
#Inputs:
    #Lt: Latitude vector.   Degrees.  +ddd.ddddd  WGS84
    #Ln: Longitude vector.  Degrees.  +ddd.ddddd  WGS84
    #ZoneNumber. Forces coordinates to this common UTM zone.

#Outputs:
    # x (east), y (north) UTM coordinates in meters.
    
    n1 = Lt.shape[0]
    n2 = Ln.shape[0]
    
    if not n1 == n2:
        raise ValueError('Lat and Lon vectors should have the same length')
    
    x = np.zeros((n1))
    y = np.zeros((n1))
    
    for i in range(0,n1):
        la = Lt[i]
        lo = Ln[i]
        
        sa = 6378137.000000
        sb = 6356752.314245
        
        e2 = (np.sqrt((sa**2)-(sb**2)))/sb
        e2sq = e2**2
        c = (sa**2)/sb
        
        lat = la*(np.pi/180)
        lon = lo*(np.pi/180)
        
        if ZoneNumber < 1:
            ZoneNumber = np.fix((lo/6) + 31)
        S = ((ZoneNumber*6) - 183)
        deltaS = lon - (S * (np.pi/180))

        a = np.cos(lat)*np.sin(deltaS)
        
        epsilon = 0.5*np.log( (1+a)/(1-a))
        
        nu = np.arctan( np.tan(lat)/np.cos(deltaS)) - lat
        
        v = (c/ np.sqrt( 1+(e2sq*(np.cos(lat)**2))))*0.9996
        
        ta = (e2sq/2)*(epsilon**2)*((np.cos(lat))**2)
        
        a1 = np.sin(2*lat)
        a2 = a1*((np.cos(lat))**2)
        j2 = lat + ( a1 / 2 )
        j4 = ( ( 3 * j2 ) + a2 ) / 4
        j6 = ( ( 5 * j4 ) + ( a2 * ( np.cos(lat) ) ** 2) ) / 3
        
        alfa = ( 3 / 4 ) * e2sq
        beta = ( 5 / 3 ) * (alfa ** 2)
        gama = ( 35 / 27 ) * (alfa ** 3)
        
        Bm = 0.9996 * c * ( lat - (alfa * j2) + (beta * j4) - (gama * j6 ))
        xx = epsilon * v * ( 1 + ( ta / 3 ) ) + 500000
        yy = nu * v * ( 1 + ta ) + Bm
        
        if yy < 0:
            yy = 9999999+yy
        
        x[i] = xx
        y[i] = yy
    return x,y

if not E_homo_hetero == 1:

    def cart2sph(x, y, z):
        hxy = np.sqrt(x**2 + y**2)
        el = np.arctan2(z, hxy)
        az = np.arctan2(y, x)
        return az, el

    def inter_has_nan(vec,elec_camp,lati,long): # Alternative method of interpolation for points ouside the E grid. Extrapolation is based on nearest-neighbour.
        FE = scipy.interpolate.NearestNDInterpolator(LatLon_Egrid,elec_camp)
        valors = np.where(np.isnan(vec),FE.__call__(lati,long),vec)
        return valors

#%% GIC calculation:

start46 = time.time()

if not E_homo_hetero == 1:
    print('E hetero')
else:
    print('E homo')

nb = L*m # Number of model buses
Lat = NodesEq[0:m,2] # Latitude  of bus nodes. Last L*m rows of columns 3 and 4 of NodesEq xls sheet. (L*m x 1) [º]
Lon = NodesEq[0:m,3] # Longitude of bus nodes. Last L*m rows of columns 3 and 4 of NodesEq xls sheet. (L*m x 1) [º]

Lat = np.reshape(Lat,(Lat.shape[0],1))
Lat_trans = np.transpose(Lat)

Lon = np.reshape(Lon,(Lon.shape[0],1))
Lon_trans = np.transpose(Lon)

# Line Infos:
RLinEq = LinesEq[:,2]/3
RLinEq[ RLinEq >= 1e6 ] = np.inf
RLinEq[np.isnan(RLinEq)] = np.inf # Branch (real TL and subs. internal branches) resistances (ntot x 1) [ohm]
nrep = LinesEq[:,3] # Number of repeated transmission lines (i.e., with the same resistance) between the same 2 buses (ntot x 1) []

NodOriLin = LinesEq[:, 0] #Origin node of each line (ntot x 1) []
NodDesLin = LinesEq[:, 1] #Destination node of each line (ntot x 1) []

BusOriLin = np.int64(NodOriLin - m) #Origin bus of each line (ntot x 1) []
BusDesLin = np.int64(NodDesLin - m) #Destination bus of each line (ntot x 1) []

#Compute the Bus Admittance Matrix (BAM)
Y0bb = np.zeros((L*m,L*m)) #Initial matrix of admittances between buses (Y^0bb) (L*m x L*m) [ohm^-1].
for lin in range(0,int(ntot)): #Fill in matrix Y^0bb.
    if BusOriLin[lin] > 0:
        Y0bb[BusOriLin[lin]-1,BusDesLin[lin]-1] = Y0bb[BusOriLin[lin]-1,BusDesLin[lin]-1] - nrep[lin]/RLinEq[lin]
        Y0bb[BusDesLin[lin]-1,BusOriLin[lin]-1] = Y0bb[BusOriLin[lin]-1,BusDesLin[lin]-1]

Ybb = sparse.csc_matrix(Y0bb - np.diag(np.full(L*m,sum(Y0bb)))) #Bus admittance matrix (L*m x L*m) [ohm^-1].
IDm = np.identity(m) # m x m unit matrix.
Ybs = np.dot(Ybb, sparse.csc_matrix(np.tile(IDm, (L,L)))) #Y^bs bus-substation admittance matrix (L*m x L*m) [ohm^-1].
YbbdiagLogical = (Ybb.diagonal() != 0) # Diagonal of Ybb (nb x 1). 0's correspond to buses not connecting to other buses (either of another or the same substation) (e.g., LV buses of GSU transformers, fictitious buses of Tee junctions, line-end buses without autotransformers).

# Diagonal of Zbn (L*m x 1) [ohm]
Zbndiag = np.reshape(RLinEq[n:],(int(nNodCon),m),order='F')
Zbndiag = np.transpose(Zbndiag[0:L,:])
Zbndiag = Zbndiag.flatten('F')

# Compute the bus-neutral point and grounding admittance matrices:
Ybn = sparse.csc_matrix(np.diag(1./Zbndiag)) #Inverse of Zbn (L*m x L*m) [ohm^-1].
Rg = NodesEq[0: m, 4]
Rg[Rg > 1e6] = np.inf
Rg[np.isnan(Rg)] = np.inf #Substation grounding resistances. (m x 1) [ohm].
Yg = 1/Rg # Substation grounding admittances. (m x 1) [ohm^-1].

#Phi transformation matrices to compute the transformer winding GICs from the bus-neutral voltages.
phiW1 = np.zeros((nTF, nb))
phiW2 = np.zeros((nTF, nb))
phiW3 = np.zeros((nTF, nb))
phiW4 = np.zeros((nTF, nb))
for Subs in range(0,m): #Loop through substations.
    for tf in range(RowsSubs.index[Subs],RowsSubs.index[Subs]+int(nTFSubs[Subs])): # Loop through all the trafos of the substation.
        # Position of the high and low voltage within the voltage levels (VL)
        indVLH = np.flatnonzero((VLSubs[:, Subs] == HVBusTF[tf])*1)
        indVLL = np.flatnonzero((VLSubs[:, Subs] == LVBusTF[tf])*1)
        if indVLL.size == 0:
            indVLL = np.nan
            
        if TFtypeTF[tf] == 'A': #Selection of Autotrafo
            # Admittances for the series windings (positive from HV to LV bus) [ohm^-1].
            phiW3[tf, indVLH*m + Subs] = 1/RphW1STF[tf]
            phiW3[tf, indVLL*m + Subs] = -1/RphW1STF[tf]
            
            phiW4[tf, indVLL*m + Subs] = 1/RphW2CTF[tf]; # Admittances for the common windings (positive from LV bus to neutral point) [ohm^-1].
            
        else: #Trafo GSU, GY-GY or Tee (Tee is not a trafo, reason by which the corresponding row of Iw will be NaN).
            # Admittances for the primary windings (positive from HV bus to neutral point) [ohm^-1].
            phiW1[tf, indVLH*m + Subs] = 1/RphW1STF[tf]
            if np.isnan(np.mean(RphW1STF[tf])) and not (TFtypeTF[tf]=='T'):
                phiW1[tf, indVLH*m + Subs] = 0
                
            # Admittances for the secondary windings (positive from LV bus to neutral point) [ohm^-1].
            if not np.isnan(indVLL):
                phiW2[tf, indVLL*m + Subs] = 1/RphW2CTF[tf]
            # else:
            #     if not (TFtypeTF[tf] == 'T'):
            #         phiW2[tf, indVLL*m + Subs] = 0 

phiW1 = sparse.csc_matrix(phiW1)
phiW2 = sparse.csc_matrix(phiW2)
phiW3 = sparse.csc_matrix(phiW3)
phiW4 = sparse.csc_matrix(phiW4)

LVBusTF_0 = np.copy(LVBusTF)
LVBusTF_0[np.isnan(LVBusTF_0)] = 0. #% Convert NaNs into zeros to compute the effective transformer GIC.

with np.errstate(divide='ignore', invalid='ignore'): # With the numpy function errstate we avoid the Runtime Warning error we obtain by dividing by 0
    # 1/TurnsRatio for full-winding transformers and for autotransformers (nTF x 1) []
    k1 = ~(np.asarray(TFtypeTF,dtype=object) == 'A')*1/(HVBusTF/LVBusTF_0)
    k1 = np.reshape(k1,(k1.shape[0],1))
    k1 = sparse.csc_matrix(k1)
    k2 = (np.asarray(TFtypeTF,dtype=object) == 'A')*1/(HVBusTF/LVBusTF_0)
    k2 = np.reshape(k2,(k2.shape[0],1))
    k2_1 = 1 - k2
    k2 = sparse.csc_matrix(k2)
    k2_1 = sparse.csc_matrix(k2_1)
        
phiTF = phiW1 + k1.multiply(phiW2) + (k2_1).multiply(phiW3)  + k2.multiply(phiW4) # Phi admittance matrix to be multiplied by the bus voltages to find the transformer effective GICs. (nTF x nb) [ohm^-1]

Ygb = np.tile(Yg,(L)) #Repeated Yg (nb x 1) [ohm^-1]
Ygb = np.reshape(Ygb,(Ygb.shape[0],1))
Ygb = sparse.csc_matrix(Ygb)

BYbn = np.dot(sparse.csc_matrix(np.tile(IDm, (1, L))),Ybn) # (m x nb) [ohm^-1]

#Calculate M (full and reduced) and decomposition (LU factorization):
M = Ybs @ Ybn + (Ygb.multiply(Ybn+Ybb)).transpose() # Original design matrix (nb x nb) [ohm^-2]. May contain 0 rows/columns which prevent inversion. These correspond to buses such as the LV bus of SUB1, or the fictitious LV bus of Sw.Sta 7 from Horton et al. 2012.

#Removing rows and columns of M corresponding to buses not connecting to others. It's like they don't exist. Mred should no longer contain 0 rows/columns. (s x s) [ohm^-2].
Mred = M[YbbdiagLogical,:]
Mred = Mred[:,YbbdiagLogical]

print('Reciprocal Condition Mred = ',1/(np.linalg.cond(Mred.toarray()))) #Display the Matlab Reciprocal Condition Number for the matrix to be inverted.

Mredlu = scipy.sparse.linalg.splu(Mred) #Creates reusable matrix decompositions (LU) that enable to solve linear systems (Ax = b or xA = b) more efficiently. 

start2 = time.time()

# Resolution of the GIC depending on whether the E-field is homogeneous or heterogeneous:

if E_homo_hetero == 1: # Homogeneous case:
    
    if E.ndim == 1:    
        E_N = E[1] # Geoelectric field components (1 x nt) [V/km]
        E_E = E[0]
        nt = 1
    else:
        E_N = E[:,1]
        E_E = E[:,0]
        nt = len(E_N)
    
        if not len(E_N)==len(E_E):
            raise ValueError('The geolectric field components have different length. Check the values of the E array')
    
    E_N = np.reshape(E_N, (E_N.shape[0],1)).transpose() # (1 x nt) [V/km]
    E_E = np.reshape(E_E, (E_E.shape[0],1)).transpose() # (1 x nt) [V/km]

    # Matrices of North and East distances between two substations. (nb x nb) [km]
    L_N = np.multiply(111.133 - 0.56*np.cos(np.deg2rad(Lat_trans + Lat)), Lat_trans - Lat)
    L_E = np.multiply(np.multiply(111.5065 - 0.1872*np.cos(np.deg2rad(Lat_trans + Lat)), np.cos(np.deg2rad((Lat_trans + Lat)/2))),Lon_trans - Lon)

    # Compute the GIC for unit electric fields in the North and East directions (E_N_uni(t) = [1 0]; E_E_uni(t) = [0 1]) and then scale with the input electric field:
    G = np.column_stack([np.sum( Ybs[:,0:m].multiply(np.tile(L_N,(L,1))), axis = 1), np.sum( Ybs[:,0:m].multiply(np.tile(L_E,(L,1))), axis = 1)]) # Gamma matrix to compute the current sources J. (nb x 2) [km/ohm]
    Jbn_uni = G # Current sources for unit electric fields (nb x 2) [A]
    Jbnred_uni = Jbn_uni[YbbdiagLogical,:] # Jbn reduced (after removing rows corresponding to buses not connecting with others) (s x 2) [A].
    
    Sred_uni = Mredlu.solve(Jbnred_uni) # (bus - neutral point voltage)*Rg [V.ohm] (s x 2).
    S_uni = np.zeros((nb,2))
    S_uni[YbbdiagLogical,:] = Sred_uni #Recovery of removed buses allocating them S_uni = 0 (nb x 2).

    # Calculate GIC to ground in each substation:
    Ig_uni = (BYbn.multiply(Ygb.transpose()))@S_uni #Bus-to-neutral point total current (sum of the 3 phases) for unit E field. (nb x 2) [A].
        
    if (np.abs(np.sum(Ig_uni)) > 1e-3).any():
        raise ValueError('Incongruent total earthing current of '+str(np.abs(np.sum(Ig_uni)))+' A. Should add to zero.')
    
    if np.abs(np.sum(Ig_uni)) > 1e-5:
     raise ValueError('Warning! The total flow to earth shoud add to zero, but it is ',str(abs(np.sum(Ig_uni))), ' A.')
    
    ag = Ig_uni[:,0] # a and b scaling constants for the grounding GIC (m x 1) [A/(V/km)].
    bg = Ig_uni[:,1]
    ag = np.reshape(ag, (ag.shape[0],1))
    bg = np.reshape(bg, (bg.shape[0],1))
    Ig = ag*E_N + bg*E_E # Grounding GIC at each substation as a function of time. (m x nt) [A].
    Ig_round2 = np.round(Ig, 2)

    # Calculate GIC fowing in each transmission line (positive when fowing from origin substation to destination substation):
    Vbn_uni = Ygb.multiply(S_uni) #Bus - neutral point voltage difference. "Vbus - Vneutral" (nb x 2) [V]. It could be obtained operating per phase as Zbn_ph*Ibn_ph = (3Zbn)*(Ibn/3) = Zbn*Ibn.
    ori = np.reshape(OriSubsLin, (OriSubsLin.shape[0],1) ) # Origin substation of each transmission line.
    des = np.reshape(DesSubsLin, (DesSubsLin.shape[0],1) ) # Destination substation of each transmission line.
    V0bbLin_uni = np.column_stack([L_N[ori-1,des-1], L_E[ori-1,des-1]]) # Bus-bus earth voltage difference for each transmission line (n x 2) [V].
    Vbn_arr = Vbn_uni.toarray()
    Yg_arr = np.reshape(Yg,(Yg.shape[0],1))
    RLin_arr = np.reshape(RLinEq[0:n], (RLinEq[0:n].shape[0],1))
    
    Ilinph_uni = (Vbn_arr[BusOriLin[0:n]-1,:] + Ig_uni[OriSubsLin[0:n]-1,:]/Yg_arr[OriSubsLin[0:n]-1,:] - Vbn_arr[BusDesLin[0:n]-1,:] - Ig_uni[DesSubsLin[0:n]-1,:]/Yg_arr[DesSubsLin[0:n]-1,:] + V0bbLin_uni)/(RLin_arr)/3 # GIC in transmission lines for unit E field (n x 2) [A/ph]
    Ilinph_uni[nrep[0: n] == 0, :] = np.nan
    al = Ilinph_uni[:,0] # a and b scaling constants for the GIC per phase at the transmission lines (n x 1) [A/ph/(V/km)]
    bl = Ilinph_uni[:,1]
    al = np.reshape(al, (al.shape[0],1))
    bl = np.reshape(bl, (bl.shape[0],1))
    Ilinph = al*E_N + bl*E_E # GIC at each transmission line as a function of time. (n x nt) [A/ph]
    Ilinph_round2 = np.round(Ilinph, 2)
    
    # Calculate winding and effective GIC flowing in transformers:
    Vbn_arr0 = Vbn_arr[:,0]
    Vbn_arr1 = Vbn_arr[:,1]
    Vbn_arr0 = np.reshape(Vbn_arr0, (Vbn_arr0.shape[0],1))
    Vbn_arr1 = np.reshape(Vbn_arr1, (Vbn_arr0.shape[0],1))
    
    aw1 = phiW1.dot(Vbn_arr0) # a and b scaling constants for the GIC at the trafo windings. Primary [A/ph/(V/km)]
    bw1 = phiW1.dot(Vbn_arr1)
    
    aw2 = phiW2.dot(Vbn_arr0) # a and b scaling constants for the GIC at the trafo windings. Scondary [A/ph/(V/km)]
    bw2 = phiW2.dot(Vbn_arr1)
    
    awser = phiW3.dot(Vbn_arr0) # a and b scaling constants for the GIC at the trafo windings. Series [A/ph/(V/km)]
    bwser = phiW3.dot(Vbn_arr1)
    
    awcom = phiW4.dot(Vbn_arr0) # a and b scaling constants for the GIC at the trafo windings. Common [A/ph/(V/km)]
    bwcom = phiW4.dot(Vbn_arr1)
    
    Iw1 = np.multiply(aw1, E_N) + np.multiply(bw1, E_E) # GIC at each trafo winding as a function of time. Primary (nTF x nt) [A/ph]
    Iw2 = np.multiply(aw2, E_N) + np.multiply(bw2, E_E) # Secondary
    Iwser = np.multiply(awser, E_N) + np.multiply(bwser, E_E) # Series
    Iwcom = np.multiply(awcom, E_N) + np.multiply(bwcom, E_E) # Common
    
    It_uni_sign = phiTF.dot(Vbn_uni).toarray() #Transformer effective GIC for unit E field (nTF x 2) [A/ph].
    at = It_uni_sign[:,0] # a and b scaling constants for the effective GIC in each trafo (nTF x 1) [A/ph/(V/km)]
    bt = It_uni_sign[:,1]
    at = np.reshape(at, (at.shape[0],1))
    bt = np.reshape(bt, (bt.shape[0],1))
    It = np.abs( np.multiply(at,E_N) + np.multiply(bt,E_E)) # Effective GIC at each trafo as a function of time. (nTF x nt) [A/ph]
    It_round2 = np.round(It,2)
    
else: # Heterogeneous case: 
    
    E_3DE = np.loadtxt(fileE_E, delimiter = ',') # Reading in eastward component of the E field in specified file. (nt x NumGridP)
    E_3DN = np.loadtxt(fileE_N, delimiter = ',') # Reading in northward component of the E field in specified file. (nt x NumGridP)
    if not E_3DE.shape[0] == E_3DN.shape[0] or not E_3DE.shape[1] == E_3DN.shape[1]: # Control
        raise ValueError('The dimensions of the E field do not match. Check for the size of E_E and E_N in the corresponding input files.')
    E_3D = np.dstack((E_3DE, E_3DN)) # E field at each point of the E grid through time. Warning! E_3D is ordered East in the first layer, North in the 2nd (nt x NumGridP x 2) [V/km].

    LatLon_Egrid = np.loadtxt(fileEgrid,delimiter = ',') # Reading in coordinates (Lat, Lon) of the E grid in specified file (NumGridP x 2) [º] 
  
    nt = E_3D.shape[0] # Number of time samples.
    
    # Calculating latitudes and longitudes of intermediate transmission line points for E field interpolation, and dx (north) and dy (east) distance elements:
    
    LatIniLin = Lat[OriSubsLin[0:n]-1] # Lat of the origin and destination of trans. lines (n x 1) [º]
    LatFinLin = Lat[DesSubsLin[0:n]-1]
    LonIniLin = Lon[OriSubsLin[0:n]-1] # Lon of the origin and destination of trans. lines (n x 1) [º]
    LonFinLin = Lon[DesSubsLin[0:n]-1]
         
    ri = np.column_stack((np.cos(np.deg2rad(LatIniLin))*np.cos(np.deg2rad(LonIniLin)),
                          np.cos(np.deg2rad(LatIniLin))*np.sin(np.deg2rad(LonIniLin)),
                          np.sin(np.deg2rad(LatIniLin)))) # Vector from Earth center to trans. line origin (n x 3) [km].
    rf = np.column_stack((np.cos(np.deg2rad(LatFinLin))*np.cos(np.deg2rad(LonFinLin)),
                          np.cos(np.deg2rad(LatFinLin))*np.sin(np.deg2rad(LonFinLin)),
                          np.sin(np.deg2rad(LatFinLin)))) # Vector from Earth center to trans. line destination (n x 3) [km].
    AngLin = np.rad2deg(np.arccos(np.sum(np.multiply(ri, rf), axis = 1))) # Angle subtended by each line as seen from the center of the Earth (maximum circle) (n x 1) []

    NPInt = np.floor(AngLin/da) + 1 # Number of intermediate points for interpolation in each line.
    MaxNPInt = np.max(NPInt) # Maximum number of NPInt.

    LonIniLin1 = np.reshape(LonIniLin,(LonIniLin.shape[0],LonIniLin.shape[1],1))   
    LonIniLin3D = LonIniLin1.transpose(2,1,0) #(1 x 1 x n)
    
    LatPIntNord = np.full((int(MaxNPInt),1,n),np.nan)
    
    for tlin in range(0,n):
        LatPIntNord[0:int(NPInt[tlin]),0,tlin] = np.arange(LatIniLin[tlin] + da/2, LatIniLin[tlin] + da*NPInt[tlin], da) # Latitude of intermediate points in the North direction (MaxNPInt x 1 x n) [].
    
    rPIntNord = np.column_stack((np.cos(np.deg2rad(LatPIntNord))*np.cos(np.deg2rad(LonIniLin3D)),
                                np.cos(np.deg2rad(LatPIntNord))*np.sin(np.deg2rad(LonIniLin3D)),
                                np.sin(np.deg2rad(LatPIntNord)))) # Unit vectors of intermediate line points in the North direction (MaxNPInt x 3 x n) [].
    
    Ang_Lin = np.reshape(AngLin,(AngLin.shape[0],1))
    cosAzi = (LatFinLin - LatIniLin)/(Ang_Lin) # Approx. cosine of the trans. line azimuth (respect to North). (n x 1) []
    #Vnord = rPIntNord.transpose(2,1,0)[:,:,0] - ri
    #Vlin = rf - ri
    #sinAzi = np.multiply(np.sign(np.sum(np.multiply(np.cross(Vlin,Vnord,axis=1),ri),axis=1)),np.transpose(np.sqrt(1-cosAzi**2)))
    #sinAzi = np.transpose(sinAzi)
    sinAzi=np.sqrt(1-cosAzi**2)
    sinAzi[LonFinLin < LonIniLin]=-sinAzi[LonFinLin < LonIniLin] # Approx. sine of line azimuth. (n x 1) []
    Azi = np.degrees(np.arctan2(sinAzi,cosAzi)) # Azimuth of trans. line resp. North. (n x 1) [º]
    
    Rc_m = 111.133 - 0.56*np.cos(np.deg2rad(LatIniLin + LatFinLin)) # pi/180 times curvature radius of Earth in the meridional and zonal directions. Equivalently, length of 1º in the meridional and zonal directions. (n x 1) [km]
    Rc_z = 111.5065 - 0.1872*np.cos((np.deg2rad(LatIniLin + LatFinLin)))
    dx = da*Rc_m*cosAzi # North and East projection of the element of line among intermediate points (n x 1) [km]. It is assumed constant through all the elements, though it is not, especially at high latitudes.
    dy = da*Rc_z*sinAzi
    
    rPInt = np.full((int(MaxNPInt), 3, n),np.nan) # Will be (n x MaxNPInt x 3).
    
    for tlin in range(0,n): # Loop to find unit vectors of the intermediate points between trans. lines
        Vec = rPIntNord[0:int(NPInt[tlin]),:,tlin]
        eixrep = np.tile(ri[tlin,:],(int(NPInt[tlin]),1))
        rPInt[0:int(NPInt[tlin]),:,tlin] = (np.transpose(np.tile(np.sum(Vec*eixrep,axis=1),(3,1)))*eixrep + 
                                            np.sin(np.deg2rad(-Azi[tlin]))*np.cross(eixrep,Vec,axis=1) +
                                            np.cos(np.deg2rad(-Azi[tlin]))*np.cross(np.cross(eixrep,Vec,axis=1),eixrep,axis=1))
        
    rPInt = rPInt.transpose(0,2,1) # Unit vectors of the intermediate points between trans. lines (MaxNPInt x n x 3) [].
    
    # Latitude, Longitude of intermediate line points (MaxNPInt x n) [º]
    LonPInt , LatPInt = cart2sph(rPInt[:,:,0],rPInt[:,:,1],rPInt[:,:,2])
    LonPInt = np.degrees(LonPInt)
    LatPInt = np.degrees(LatPInt)
    
    start1 = time.time()
    punts_lat = np.isfinite(LatPInt).transpose()
    punts_lon = np.isfinite(LonPInt).transpose()
    
    LatPInt_finit = LatPInt.transpose()[punts_lat] # #Latitude, Longitude of intermediate line points in a row (nz x n) [º]
    LonPInt_finit = LonPInt.transpose()[punts_lon]
    
    nz = LatPInt_finit.shape[0] # Number of geological zones.
    MatInt = np.copy(np.transpose(LatPInt))
    MatInt[np.isfinite(MatInt)] = np.arange(1,nz+1)
    IndIni = MatInt[:,0]
    IndFin = IndIni + np.transpose(NPInt) - 1
    IndIni = np.int64(IndIni)
    IndFin = np.int64(IndFin)
    
    Ex_i = np.full((nz, nt), np.nan) # x (North) and y (East) components of the interpolated geoelectric field [V/km].
    Ey_i = np.copy(Ex_i)
    
    start2 = time.time()
    
    print('Time step:')
    for t in range(0,nt):
        if round(t/100) == t/100:
            print('t = '+str(t))
        
        FEx = scipy.interpolate.LinearNDInterpolator(LatLon_Egrid, np.transpose(E_3D[t,:,1])) # Bi-linear interpolating object for Ex component (Nord).
        FEy = scipy.interpolate.LinearNDInterpolator(LatLon_Egrid, np.transpose(E_3D[t,:,0])) # Bi-linear interpolating object for Ey component (East).
        Ex_i[:,t] = FEx.__call__(LatPInt_finit,LonPInt_finit) # x (North) component of the interpolated geoelectric field [V/km].
        Ey_i[:,t] = FEy.__call__(LatPInt_finit,LonPInt_finit) # y (East) component of the interpolated geoelectric field [V/km].
        
        # Off-grid points are exptrapolated by nearest neighbour:
        if np.isnan(np.sum(Ex_i[:,t])) == True:
            Ex_i[:,t] = inter_has_nan(Ex_i[:,t],np.transpose(E_3D[t,:,1]),LatPInt_finit,LonPInt_finit)
        
        if np.isnan(np.sum(Ey_i[:,t])) == True:
            Ey_i[:,t] = inter_has_nan(Ey_i[:,t],np.transpose(E_3D[t,:,0]),LatPInt_finit,LonPInt_finit)
        
    #Calculating Gamma, the matrix multiplying E to find the current sources J (J = G*E), and the voltage difference among the buses joining a given trans. line:
    
    frac = AngLin/da - (NPInt - 1) #Fractionary part at the end of each line.
    V0bbLin = np.zeros((n,nt))
    G = np.zeros((nb,2*nz)) #Gamma matrix to compute the current sources J. (nb x 2nz) [km/ohm]
    
    for tlin in range(0,n):
        BusOriLintlin = BusOriLin[tlin]-1
        BusDesLintlin = BusDesLin[tlin]-1      
        
        if not any( (BusOriLin[0:tlin]-1 == BusOriLintlin) * (BusDesLin[0:tlin]-1 == BusDesLintlin) + (BusOriLin[0:tlin]-1 == BusDesLintlin) * (BusDesLin[0:tlin]-1 == BusOriLintlin)):
            
            G[BusOriLintlin, IndIni[tlin]-1 : IndFin[tlin]-1] = dx[tlin]*Ybb[BusOriLintlin, BusDesLintlin]
            G[BusOriLintlin, IndFin[tlin]-1] = dx[tlin]*Ybb[BusOriLintlin, BusDesLintlin]*frac[tlin]
            
            G[BusOriLintlin, nz+IndIni[tlin]-1: nz+IndFin[tlin]-1 ] = dy[tlin]*Ybb[BusOriLintlin,BusDesLintlin]
            G[BusOriLintlin, nz + IndFin[tlin]-1] = dy[tlin]*Ybb[BusOriLintlin, BusDesLintlin]*frac[tlin]

            G[BusDesLintlin, IndIni[tlin]-1 : IndFin[tlin]] = - G[BusOriLintlin, IndIni[tlin]-1 : IndFin[tlin]]
            G[BusDesLintlin, nz+IndIni[tlin]-1: nz+IndFin[tlin]] = - G[BusOriLintlin, nz+IndIni[tlin]-1: nz+IndFin[tlin]]
            
        V0bbLin[tlin,:] = dx[tlin]*(np.sum(Ex_i[IndIni[tlin]-1:IndFin[tlin]-1,:],axis = 0) + Ex_i[IndFin[tlin]-1,:]*frac[tlin]) + dy[tlin]*(np.sum(Ey_i[IndIni[tlin]-1:IndFin[tlin]-1,:],axis = 0) + Ey_i[IndFin[tlin]-1,:]*frac[tlin]) # Voltage difference among the buses joining a given trans. line. (n x 1) [V]
     
    G = sparse.csc_matrix(G)
    
    E_inter = np.vstack((Ex_i,Ey_i))
    Jbn = G*E_inter
    Jbnred = Jbn[YbbdiagLogical, :] # Current sources (nb x nt) [A]. Jbnred is Jbn reduced (after removing rows corresponding to buses not connecting with others).

    Sred = Mredlu.solve(Jbnred) # (bus - neutral point voltage)*Rg [V.ohm] (s x nt).
    S = np.zeros((nb,nt))
    S[YbbdiagLogical, :] = Sred # Recovery of removed buses allocating them S = 0 (nb x nt)
    
    #Calculate GIC to ground in each substation:
    Ig = (BYbn.multiply(Ygb.transpose()))*S # Earthward GIC in each substation (m x nt) [A]
    
    if (np.abs(np.sum(Ig)) > 1e-3).any(): # Control
        raise ValueError(['Incongruent total earthing current of '+str(np.abs(np.sum(Ig)))+' A. Should add to zero.'])
    if (np.abs(np.sum(Ig)) > 1e-5).any():
        print(['Warning! The total flow to earth should add to zero, but it is '+str(np.abs(np.sum(Ig)))+' A.'])
    
    Vbn = Ygb.multiply(S) # Bus - neutral point voltage difference. "Vbus - Vneutral" (nb x nt) [V]. It could be obtained operating per phase as Zbn_ph*Ibn_ph = (3Zbn)*(Ibn/3) = Zbn*Ibn.
    
    Vbn_arr = Vbn.toarray()
    RLin_arr = np.reshape(RLinEq[0:n], (RLinEq[0:n].shape[0],1))
    Yg_arr = np.reshape(Yg,(Yg.shape[0],1))

    #Calculate GIC flowing in transmission lines (positive when flowing from origin substation to destination substation):
    Ilinph = (Vbn_arr[BusOriLin[0:n]-1,:] + Ig[OriSubsLin[0:n]-1]/Yg_arr[OriSubsLin[0:n]-1] - Vbn_arr[BusDesLin[0:n]-1,:] - Ig[DesSubsLin[0:n]-1]/Yg_arr[DesSubsLin[0:n]-1] + V0bbLin)/(RLin_arr)/3
    Ilinph[nrep[0: n] == 0, :] = np.nan # GIC in transmission lines (n x nt) [A/ph]

    #Calculate winding and effective GIC flowing in transformers:
    Iw1 = phiW1*Vbn # Transformer winding GICs (nTF x nt) [A/ph].
    Iw2 = phiW2*Vbn
    Iwser = phiW3*Vbn
    Iwcom = phiW4*Vbn
    It = np.abs(phiTF*Vbn) # Transformer effective GIC (nTF x nt) [A/ph].
    
    Iw1 = Iw1.toarray()
    Iw2 = Iw2.toarray()
    Iwser = Iwser.toarray()
    Iwcom = Iwcom.toarray()
    It = It.toarray()
    
print('GIC calculation time (s):',(time.time()-start2))
print('Cell 3 elapsed time:',time.time()-start46)

#%% Figura: Representation of possible substations outside the E grid.

if ShowFigures == 1:
    Y_UTM0 , X_UTM0 = deg2utm_zone(np.tile(Lat,(L,1)),np.tile(Lon,(L,1)),ForceUTMZoneTo)
    XY_UTM = np.column_stack((X_UTM0, Y_UTM0))/1000 # X (nord), Y (est) "UTM" coordinates of all the buses (nb x 2) [km]
    Coord = np.column_stack((XY_UTM[:,1],XY_UTM[:,0])) # Change the order, i.e, (Y, X).
    
    if not len(BaseMapFile) == 0: # If a base map file has been specified ...
        if BaseMapFileDataType == 1: # If the base map contains (Lat, Lon) data ...
            LatLonMap = np.loadtxt(BaseMapFile, delimiter = ',') # Reading-in map.
            Y_UTMMap , X_UTMMap = deg2utm_zone(LatLonMap[:,0],LatLonMap[:,1],ForceUTMZoneTo) # UTM coordinates of map.
            UTM_Map = np.column_stack((Y_UTMMap, X_UTMMap))/1000 # Change order and convert to km [km].
        else:
            UTM_Map = np.loadtxt(BaseMapFile)/1000 # UTM data of the boundaries. Must be given in a common UTM zone = ForceUTMZoneTo [km]
    
    if Check_Extrap == 1: # If user wants to check the extrapolation of off-grid substations ...
        TimeIndexShowInterp = 0 # User defined. Time index for which the user wants to check the extrapolation.
        # Interpolate the data to be represented:
        FEx = scipy.interpolate.LinearNDInterpolator(LatLon_Egrid, np.transpose(E_3D[TimeIndexShowInterp,:,1])) # Bi-linear interpolating object for Ex and Ey components (Nord).
        FEy = scipy.interpolate.LinearNDInterpolator(LatLon_Egrid, np.transpose(E_3D[TimeIndexShowInterp,:,0]))
        
        elec_field = np.zeros((m,2))
        newCoordSubs = np.full((m,2),np.nan) 
        # Coordinates of off-grid substations, for which extrapolation is required:
        for Subs in range(0,m):
            plt.plot(LatLonSubs[Subs,1],LatLonSubs[Subs,0],'go',markersize=1)
            Ex_i = FEx.__call__(LatLonSubs[Subs,0],LatLonSubs[Subs,1])
            Ey_i = FEy.__call__(LatLonSubs[Subs,0],LatLonSubs[Subs,1])
            
            # Check that E field is not a nan:
            if (np.isnan(np.sum(Ex_i))==True) or (np.isnan(np.sum(Ey_i))==True):
                Ex_i = inter_has_nan(Ex_i,np.transpose(E_3D[TimeIndexShowInterp,:,1]),LatLonSubs[Subs,0],LatLonSubs[Subs,1]) # Re-interpolation with Nearest method to find external points.
                Ey_i = inter_has_nan(Ey_i,np.transpose(E_3D[TimeIndexShowInterp,:,0]),LatLonSubs[Subs,0],LatLonSubs[Subs,1])
                newCoordSubs[Subs,0] = Coord[Subs,0]
                newCoordSubs[Subs,1] = Coord[Subs,1]
            
            elec_field[Subs,0] = Ex_i # Extrapolated E field.
            elec_field[Subs,1] = Ey_i
        
        # Map highlighting off-grid substations:
        plt.figure()
        if not len(BaseMapFile) == 0:
            plt.plot(UTM_Map[:,0],UTM_Map[:,1],'k')
        
        plt.axis('equal')
        plt.xlabel('Easting (km)',fontsize = 15)
        plt.ylabel('Northing (km)',fontsize = 15)
        
        for tlin in range(0,n): # Add trans. lines
            plt.plot((Coord[OriSubsLin[tlin]-1,0],Coord[DesSubsLin[tlin]-1,0]),
                      ((Coord[OriSubsLin[tlin]-1,1],Coord[DesSubsLin[tlin]-1,1])),'r')
        
        plt.plot(newCoordSubs[:,0],newCoordSubs[:,1],'ko') # Add off-grid substations.
        
        yEgrid_hus , xEgrid_hus = deg2utm_zone(LatLon_Egrid[:,0], LatLon_Egrid[:,1],ForceUTMZoneTo)
        Egrid_UTM = np.column_stack((xEgrid_hus, yEgrid_hus))/1000
        plt.plot(Egrid_UTM[:,1],Egrid_UTM[:,0],'bo',markersize=1) # Add E grid
        plt.show()
    
    
        # Figure: E-field (North and Esat components) of off-grid substations:
        SubsOutY = np.argwhere(~np.isnan(newCoordSubs[:,0]))
        #SubsOutX = np.argwhere(~np.isnan(newCoordSubs[:,1]))
        
        plt.figure()
        plt.subplot(2,1,1)
        plt.plot(SubsOutY,elec_field[SubsOutY,0],'bo')
        plt.title('Ex_i (Nord)')
        plt.subplot(2,1,2)
        plt.plot(SubsOutY,elec_field[SubsOutY,1],'bo')
        plt.title('Ey_i (Est)')
        plt.show()

#%% Map representing the maximum grounding absolute GIC in each substation by circles with radii proportional to GIC during an event.

if ShowFigures == 1:
    VLNet = np.flipud(np.unique(VLSubs[np.isfinite(VLSubs)])) # Voltage levels of the network

    # Color codes of trans. lines of a given voltage. From low to high:
    CodColors = np.array(([255,102,102],[51,204,255],[0,0,0]))/255
    CodColors = np.tile(CodColors,(np.ceil(len(VLNet)/CodColors.shape[0]),1) )
    CodColors = CodColors[0: len(VLNet), :]
    
    # Max. GIC during the event:
    Iemax = np.max(np.abs(Ig),axis=1) # Maximum GIC for each substation.
    Iemaxtot = np.max(Iemax) # Absolute maximum.
    
    plt.figure()
    if not len(BaseMapFile) == 0:
        plt.plot(UTM_Map[:,0],UTM_Map[:,1],'k')
    plt.axis('equal')
    plt.xlabel('Easting (km)',fontsize = 15)
    plt.ylabel('Northing (km)',fontsize = 15)
    
    for tlin in range(0,n): # Plot trans. lines according to ColorCode.
        plt.plot((Coord[OriSubsLin[tlin]-1,0],Coord[DesSubsLin[tlin]-1,0]), ((Coord[OriSubsLin[tlin]-1,1],Coord[DesSubsLin[tlin]-1,1])), color = CodColors[VLNet == VTLin[tlin],:])
    
    scale = 58.3 # Scale [A]. This GIC will be assigned a circle of radius = 50 units.
    mida = Iemax*50/scale # Circle radius.
    
    # Circles are defined as Patches corresponding to a figure to be inserted within our figure. That's why we frst call for any axisting figure:
    fig = plt.gcf() 
    
    # Once we have our figure, take the axes:
    ax = fig.gca()
    
    # Draw the reference circle:
    cercle_ref = plt.Circle((900,4200),radius = 50*50/scale,fill = False)
    
    # ... and add it to our figure with add_patch, which allows us insert a new object.
    ax.add_patch(cercle_ref)
    
    plt.text(980,4200,'50 A')
    
    # Now draw a circle for each substation:
    for i in range(0,m):
        if mida[i] > 0:
            cercle_gic = plt.Circle((XY_UTM[i,1],XY_UTM[i,0]),radius = mida[i],fill = False,color='b')
            ax.add_patch(cercle_gic)
    
    plt.title('Max. absolute GIC to ground = '+str(np.round(Iemaxtot,1))+' A')
    plt.show()

#%% Map showing max. GIC per phase in each trans. line.

if ShowFigures == 1:

    IniLin = np.full((n,2),np.full)
    FinLin = np.full((n,2),np.full)
    for tlin in range(0,n): # Loop through each line:
        IniLin[tlin,:] = XY_UTM[BusOriLin[tlin]-1,:] # X(N), Y(E) UTM coordinates of line origin [km].
        FinLin[tlin,:] = XY_UTM[BusDesLin[tlin]-1,:] # X(N), Y(E) UTM coordinates of line destination [km].
    
    Ifasemax = np.max(np.abs(Ilinph),axis=1) # Maximum GIC/ph for each line.
    Ifasemaxtot = np.max(Ifasemax) # Absolute maximum.
    
    plt.figure()
    if not len(BaseMapFile) == 0:
        plt.plot(UTM_Map[:,0],UTM_Map[:,1],'k')
    plt.axis('equal')
    plt.xlabel('Easting (km)',fontsize = 15)
    plt.ylabel('Northing (km)',fontsize = 15)
    
    ColorMat = plt.get_cmap('jet') # Pre-defined color map.
    AmpLin = VTLin/220 + 0.1 # Line width of each voltage level.
    
    # Plotting the lines.
    for tlin in range(0,n):
        if not Ifasemax[tlin] == 0:
            plt.plot([IniLin[tlin,1],FinLin[tlin,1]],[IniLin[tlin,0],FinLin[tlin,0]], color = ColorMat(np.ceil(ColorMat.N/(Ifasemaxtot)*Ifasemax[tlin])/ColorMat.N), linewidth = AmpLin[tlin])

    # Plotting the substation locations.
    for i in range(0,m):
        plt.plot(XY_UTM[i,1],XY_UTM[i,0],'ko',markersize = 2)
    
    # Colorbar:
    sm = plt.cm.ScalarMappable(cmap='jet', norm=plt.Normalize(vmin=0, vmax=np.round(Ifasemaxtot)))
    plt.colorbar(sm,label = 'A/ph')
    plt.title('Max. absolute GIC in transimission lines = '+str(np.round(Ifasemaxtot,1))+' A/ph')
    plt.show()

#%% Video: Grounding GIC through the event:

if ShowFigures == 1 and not len(SaveVideoAs) == 0: 
    
    SaveVideoAs = SaveVideoAs+'.avi' # Add .avi extension
    
    scale = 40 # Scale [A]. This GIC will be assigned a circle of radius = 50 units.
    midavid = Ig*50/scale
    tIniVideo = 0 # First time index for video frames.
    tFinVideo = nt # Last time index for video frames.
    
    frames = [] # List of frames
    
    datetime_start_obj = datetime.strptime(datetime_video_start, "%Y-%m-%d %H:%M") # Converts datetime string to object.
    for t in range(tIniVideo,tFinVideo): # Loop for each video frame:
        plt.figure()
        new_datetime_obj = datetime_start_obj + dati.timedelta(minutes = (t - tIniVideo)) # New time. 1-min time step is assumed
        new_datetime_obj_str = str(new_datetime_obj)
        
        if not len(BaseMapFile) == 0: # Plot base map.
            plt.plot(UTM_Map[:,0],UTM_Map[:,1],'k')
        plt.axis('equal')
        plt.xlabel('Easting (km)',fontsize = 15)
        plt.ylabel('Northing (km)',fontsize = 15)
        
        for tlin in range(n): # Plot trans. lines.
            plt.plot((Coord[OriSubsLin[tlin]-1,0],Coord[DesSubsLin[tlin]-1,0]), ((Coord[OriSubsLin[tlin]-1,1],Coord[DesSubsLin[tlin]-1,1])), color = CodColors[VLNet == VTLin[tlin],:])
        
        plt.title('GIC(t) to ground')
        
        """
        #Data for Spain:
        plt.xlim((-600,600))
        plt.ylim((-500,500))
        plt.text(430,-350,'50 A')
        cercle_ref = plt.Circle((350,-350),radius = 50*50/escala,fill = False)
        """
        
        "Data for USA"
        plt.xlim((0,2000))
        plt.ylim((2500,4200))
        plt.text(1800,2800,'50 A')
        cercle_ref = plt.Circle((1700,2800),radius = 50*50/scale,fill = False)
        
        fig = plt.gcf() 
        ax = fig.gca()
        ax.add_patch(cercle_ref)
        for i in range(m): # Loop through each substation to plot the corresponding circle.
            if midavid[i,t] >= 0:
                cercle_gic = plt.Circle((XY_UTM[i,1],XY_UTM[i,0]),radius = midavid[i,t],fill = False,color='r') # Red circle for positive GIC (to ground).
            if midavid[i,t] < 0:
                cercle_gic = plt.Circle((XY_UTM[i,1],XY_UTM[i,0]),radius = -midavid[i,t],fill = False,color='b') # Blue circle for positive GIC (from ground).
            ax.add_patch(cercle_gic)
            
        ax.annotate(new_datetime_obj_str, xy = (50,2550)) # Date and time string.
        fig.canvas.draw()

        # Now we can save it to a numpy array:
        data = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
        data = data.reshape(fig.canvas.get_width_height()[::-1] + (3,)) 
        data = cv2.cvtColor(data,cv2.COLOR_RGB2BGR)
        frames.append(data)
        plt.close(fig)

    print('Frames created')
    height, width, _ = frames[0].shape
    v = cv2.VideoWriter(SaveVideoAs,cv2.VideoWriter_fourcc(*'DIVX'),5,(width,height))
    for im in frames:
        v.write(im)
    v.release()

#%% Bar figure: max. GIC/phase flowing in each trafo (through any of its windings) throughout the event.

if ShowFigures == 1:
    HVLTF = HVBusTF[np.isfinite(HVBusTF)] #High voltage level of each trafo in the network [kVAC] (nTF x 1).
    if not len(HVLTF) == nTF:
        raise ValueError 
    
    HVLTFSort = np.flipud(np.unique(HVLTF[HVLTF > 0]))
    
    TFnum = np.arange(0,nTF)
    
    Iw1max = np.max(np.abs(Iw1),axis = 1) # Max. GIC (absolute value) in primary winding of each trafo throughout the event. [A/ph] (nTF x 1)
    Iw2max = np.max(np.abs(Iw2),axis = 1) # Max. GIC (absolute value) in secondary winding of each trafo throughout the event. [A/ph] (nTF x 1)
    Iwsermax = np.max(np.abs(Iwser),axis = 1) # Max. GIC (absolute value) in series winding of each trafo throughout the event. [A/ph] (nTF x 1)
    Iwcommax = np.max(np.abs(Iwcom),axis = 1) # Max. GIC (absolute value) in common winding of each trafo throughout the event. [A/ph] (nTF x 1)
    
    Iwmax = np.column_stack((Iw1max,Iw2max,Iwsermax,Iwcommax))
    Iwmax = np.nanmax(Iwmax, axis = 1) # Max. GIC flowing through all the windings of each trafo throughout the event. [A/ph] (nTF x 1)
    
    plt.figure()
    
    CodColors2 = ['r','b','g','k','r','b','g','k'] # Color code of the high voltage of each trafo. Colors ordered from high to low voltage.
    
    for HVLpos in range(0,len(HVLTFSort)):
        plt.bar(TFnum[HVLTF == HVLTFSort[HVLpos]]+1,Iwmax[HVLTF == HVLTFSort[HVLpos]], color = CodColors2[HVLpos],width = 0.1) # Plot bars
    
    plt.xlabel('# Trafo',fontsize = 15)
    plt.ylabel('GIC (A/phase)',fontsize = 15)
    plt.title('Peak winding GIC flow throuhgout all the windings of each transformer',fontsize = 15)
    plt.show()
#%% Figure: Plot the GIC flowing in a given line vs. time

if ShowFigures == 1:
    def isfloat(value):
      try:
        float(value) # Try to convert input from command line from string to number.
        return True
      except ValueError: 
        return False # Otherwise return error.
    
    print('Insert the line number for which you want to plot the GIC (press Enter if none). Lines range from 1 to '+str(n))
    nlinstr = input('Selected line: ')
    
    if isfloat(nlinstr): # Plot line GIC vs. time
        nlin = int(nlinstr)-1
        if nlin >=0 and nlin<= n:
            plt.figure()
            tm = 60 # Sampling time [s].
            x_values = np.arange(0,Ilinph.shape[1])*tm/3600
            plt.plot(x_values,3*Ilinph[nlin,:],'b')
            plt.xlim(0,Ilinph.shape[1]*tm/3600)
            plt.title('GIC Line '+str(nlinstr))
            plt.grid(axis='y')
            plt.xlabel('Time [h]',fontsize = 14)
            plt.ylabel('GIC [A]',fontsize = 14)
        else:
            print('This line does not exist!')
     
#%% Checking total time of the program

print('Elapsed time:',time.time() - start)

