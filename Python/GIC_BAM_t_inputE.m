% Property: Observatori de l'Ebre. Author: Santiago Marsal Vinadé.
% License: GNU General Public License 3 (GPL-3.0) (http://opensource.org/licenses/GPL-3.0)

% Construction of a DC-equivalent network and GIC computation over time in a power network by means of the Bus Admittance Matrix (BAM).
% Version: v2.0 (faster process inverting Sred matrix over time at a time).
% Input:
%  - Real network parameters (line and grounding resistances, transformer types and winding resistances, substation locations, ...) conveniently arranged in input Excel file. Assumed constant in time.
%  - Geoelectric field over time. It may be either homogeneous (constant in space) or heterogeneous (variable in space). If heterogeneous, the E field is given in a grid covering the power network area. The E field in the entire power network is interpolated from this grid.
%       Note: Heterogeneous E-fields are assumed to have been generated by other means (e.g., from magnetic field and earth conductivity data).
% Output:
%  - Ig: GIC flow to earth in substation earthing over time,
%  - Ilinph: GIC flow per phase in each transmission line over time.
%  - Iwi: GIC flow in transformer windings (/phase) over time.
%  - It: effective GIC flow in transformers (/phase) over time.
%  
% Abbreviations used:
%     nt -> number of time steps.
%     NumGridP -> number of grid points where the E field is given.
%     nTF -> Number of transformers in the power grid.
%     n -> Number of transmission lines in power grid.
clearvars

%%%%%%%%% START INPUT PARAMETERS: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
XLSInpFileName = '.\BenchmarkGrid.xlsx'; % Name of the input Excel file containing the actual and equivalent networks.
% XLSInpFileName = '.\Horton&BotelerGrid.xlsx'; % Name of the input Excel file containing the actual and equivalent networks.
% XLSInpFileName = '.\TstGrid_a.xlsx'; % Name of the input Excel file containing the actual and equivalent networks.
% XLSInpFileName = '.\TstGrid_b.xlsx'; % Name of the input Excel file containing the actual and equivalent networks.

WriteEqNetXLS = 0; % If 1, writes equivalent network in the input Excel file (creates new 'NodesEq' and 'LinesEq' sheets); otherwise, 0. Warning: writing in Excel slows down the process.
E_homo_hetero = 1; % 1 if E is homogeneous; 2 if heterogeneous.

if E_homo_hetero == 1 % Homogeneous case:
%      E_E(t)   E_N(t) % Homogeneous geoelectric field. Warning! First and second columns are the East and North components over time, respectively. [V/km] (nt x 2)
    E = [0        1; ... % t1
         1        0; ... % t2
         1        1];
%      ...      ...];    % tn
else % Hoterogeneous case:
    da = 0.1; % Element of transmission line angle to integrate the geoelectric field along the line for the heterogeneous earth conductivity case. This can be estimated as sqrt(land surface/NumPEDI)/3/110, where NumPEDI is the number of nodes in the grid where the earth's conductivity is known. [º]
    % Text files containing the E field in a grid. One component (East and North) per file:
    fileE_E = 'E_2D_East.txt'; % Comma-separated values of the East component of the E field. The file contains one row per time step and one column per grid point. [V/km] (nt x NumGridP)
    fileE_N = 'E_2D_North.txt'; % Comma-separated values of the North component of the E field. The file contains one row per time step and one column per grid point. [V/km] (nt x NumGridP)
    fileEgrid = 'LatLon_Egrid_SE_USA.txt'; % Comma-separated values with Latitude, Longitude (in decimal degrees) of each grid point. (NumGridP x 2)
end

ShowFigures = 1; % 1 to show figures; 0 otherwise
if ShowFigures
    BaseMapFile = 'LatLon_SE_USA.txt'; % Name of the base map file typically containing coordinates of the coastlines. If empty ('') no base map is loaded.
    BaseMapFileDataType = 1; % if 1 the data of the BaseMapFile are given in Lat, Lon format; otherwise, data are given in UTM coordinates.
    ForceUTMZoneTo = 16; % Force UTM zone to this value for representation purposes. E.g.: 9-20 for USA, 30 for Spain, ... See, e.g., https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system
    %Check_Extrap = 0; % 1 shows map of off-grid substations and corresponding extrapolated E field for a user-defined time.
    SaveVideoAs = 'Ig_Benchmark'; % Name of the video (.avi) to be saved, showing grounding GIC (Ig) through time. If empty ('') no video is generated. E.g.: 'MyVideo'.
    if ~isempty(SaveVideoAs) % Applies for non-empty video name.
        datetime_video_start = '2022-11-14 23:41'; % Date & time for the initial video frame. See tIniVideo and tFinVideo variables below.
    end
end
%%%%% END INPUT PARAMETERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Parameters read in the specified Excel file: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[SubsNumInfo, SubsTxtInfo, ~] = xlsread(XLSInpFileName, 'Substations'); % Reading several infos from 'Substations' XLS sheet (transformer winding resistances and bus voltage levels).
LinesInp = xlsread(XLSInpFileName, 'Lines'); % Input from 'Lines' XLS sheet.

SubsNumInfo = [NaN*SubsNumInfo(:, 1), SubsNumInfo]; % Place NaN column at the beginning to coincide with original columns in Excel file.

% Checking Excel data content; if not OK, release warning:
if size(SubsNumInfo, 2) > 12; errordlg('Too many numerical columns in ''Substations'' sheet. Please, make sure all rows in the first column are text cells and there is no further information in the sheet other than required.', 'File error'); end
if size(SubsNumInfo, 2) < 11; errordlg('Not enough numerical columns in ''Substations'' sheet. Please, make sure the entered information is complete.', 'File error'); end
if size(SubsNumInfo, 2) == 11; SubsNumInfo = [SubsNumInfo, NaN(size(SubsNumInfo, 1))]; end % Complete last column of 'Substations' sheet in case it is empty (case of a single voltage level).
if size(LinesInp, 2) ~= 6; errordlg('Incorrect number of numerical columns in ''Lines'' sheet. Should be 6. Please, make sure the entered information is complete and there are no exceeding columns.', 'File error'); end

% Determine the original number of substations, transformers and lines, and more checking:
RowsSubs = find(~isnan(SubsNumInfo(:, 2))); % Array containing the first row (excluding header!) of each substation.
m = length(RowsSubs); % nº of substations in the network.
nTF = sum(SubsNumInfo(RowsSubs, 6)); % nº of transformers in the network.
n = size(LinesInp, 1); % nº of real transmission lines in the network (repeated transmission lines, i.e., with the same resistance between the same 2 buses are counted as 1, so nº of transects indeed).
for col = [3, 4, 6]; if ~isequaln(isnan(SubsNumInfo(:, 2)), isnan(SubsNumInfo(:, col))); errordlg('Columns 3, 4 and 6 should have the same non-empty rows as column 2', 'File error'); end; end % Control. Columns 2, 3 and 5 should have nSUB non-empty cells.
if nTF ~= size(SubsNumInfo, 1); errordlg('The number of transformers (column 6) should be consistent with the number of rows of ''Substations'' sheet.', 'File error'); end % Control. The number of transformers should be consistent with the number of rows.
if any(SubsNumInfo(~isnan(SubsNumInfo(:, 2)), 2) ~= (1: m)'); errordlg('Substation numbers should be consecutive from 1 to m (number of substations).', 'File error'); end % Control. Substation numbers (column 2 of Substations sheet) should be consecutive from 1 to m.
if any(isnan(LinesInp(:, 6))) ; errordlg('Line voltage [kVAC] (column 6 of ''Lines'' sheet) cannot be empty.', 'File error'); end % Control.

% Data read in 'Substations' sheet:
LatLonSubs = SubsNumInfo(RowsSubs, 3: 4); % Substation latitude and longitude. (m x 2) [º]
RgSubs = SubsNumInfo(RowsSubs, 5); % Substation earthing resistances. (m x 1) [ohm]
nTFSubs = SubsNumInfo(RowsSubs, 6); % nº of transformers in each substation. (m x 1) []
TxtRefTF = SubsTxtInfo(2: end, 7); % Transformer reference. (nTF x 1) [text]
RphW1STF = SubsNumInfo(:, 8); % Transformer primary/series winding resistance per phase. (nTF x 1) [ohm/ph]
RphW2CTF = SubsNumInfo(:, 9); % Transformer secondary/common winding resistance per phase. (nTF x 1) [ohm/ph]
TFtypeTF = SubsTxtInfo(2: end, 10); % Transformer type. (nTF x 1) [text]
HVBusTF = SubsNumInfo(:, 11); % Transformer high-voltage bus. (nTF x 1) [kVAC]
LVBusTF = SubsNumInfo(:, 12); % Transformer low-voltage bus. (nTF x 1) [kVAC]
% Data read in 'Lines' sheet:
OriSubsLin = LinesInp(:, 1); % Transmission line origin substation. (n x 1) []
DesSubsLin = LinesInp(:, 2); % Transmission line destination substation. (n x 1) []
RphLin = LinesInp(:, 3); % Transmission line resistance per phase. (n x 1) [ohm/ph]
nrepLin = LinesInp(:, 4); % Number of repetitions of each transmission line. (n x 1) []
VTLin = LinesInp(:, 6); % AC voltage of each transmission line. (n x 1) [kVAC]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Once parameters read in, construct the DC-equivalent network in separate subprogram: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ConsEqNet
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tic
disp(XLSInpFileName)
if E_homo_hetero ~= 1; disp('E hetero'); else; disp('E homo'); end
nb = L*m; % Number of model buses.

Lat = NodesEq(1: m, 3); % Latitude of bus nodes. Last nb rows of column 3 of NodesEq xls sheet. (nb x 1) [º].
Lon = NodesEq(1: m, 4); % Longitude of bus nodes. Last nb rows of column 4 of NodesEq xls sheet. (nb x 1) [º].

% Line infos:
RLinEq = LinesEq(:, 3)/3; RLinEq(RLinEq > 1e6 | isnan(RLinEq)) = Inf; % Branch (real TL and subs. internal branches) resistances (ntot x 1) [ohm]
nrep = LinesEq(:, 4); % Number of repeated transmission lines (i.e., with the same resistance) between the same 2 buses (ntot x 1) []
NodOriLin = LinesEq(:, 1); NodDesLin = LinesEq(:, 2); % Origin and destination node of each line (ntot x 1) []
BusOriLin = NodOriLin - m; BusDesLin = NodDesLin - m; % Origin and destination bus of each line (ntot x 1) []

% Compute the Bus Admittance Matrix (BAM):
Y0bb = zeros(nb); % Initial matrix of admittances between buses (Y^0bb) (nb x nb) [ohm^-1].
for lin = 1: ntot % Fill in matrix Y^0bb.
    if BusOriLin(lin) > 0
        Y0bb(BusOriLin(lin), BusDesLin(lin)) = Y0bb(BusOriLin(lin), BusDesLin(lin)) - nrep(lin)/RLinEq(lin);
        Y0bb(BusDesLin(lin), BusOriLin(lin)) = Y0bb(BusOriLin(lin), BusDesLin(lin));
    end
end
Ybb = sparse(Y0bb - diag(sum(Y0bb))); % Bus admittance matrix (nb x nb) [ohm^-1].
IDm = speye(m); Ybs = Ybb*repmat(IDm, L); % Y^bs bus-substation admittance matrix (nb x nb) [ohm^-1].
YbbdiagLogical = logical(diag(Ybb)); % Diagonal of Ybb (nb x 1). 0's correspond to buses not connecting to other buses (either of another or the same substation) (e.g., LV buses of GSU transformers, fictitious buses of Tee junctions, line-end buses without autotransformers).

% Compute the grounding and bus-neutral point admittance matrices:
Zbndiag = reshape(RLinEq(n + 1: end), nNodCon, m); Zbndiag = Zbndiag(1: L, :)'; % Diagonal of Zbn (nb x 1) [ohm]
Ybn = sparse(diag(1./Zbndiag(:))); % Inverse of Zbn (nb x nb) [ohm^-1].
Rg = NodesEq(1: m, 5); Rg(Rg > 1e6 | isnan(Rg)) = Inf; % Substation grounding resistances. (m x 1) [ohm].
Yg = 1./Rg; % Substation grounding admittances. (m x 1) [ohm^-1].

% Phi transformation matrices to compute the transformer winding GICs from the bus-neutral voltages.
phiW1 = zeros(nTF, nb); phiW2 = phiW1; phiW3 = phiW1; phiW4 = phiW1; % (nTF x nb) [ohm^-1]
for Subs = 1: m % Loop through substations.
    for tf = RowsSubs(Subs): RowsSubs(Subs) + nTFSubs(Subs) - 1 % Loop through all the trafos of the substation.
        indVLH = find(VLSubs(:, Subs) == HVBusTF(tf)); indVLL = find(VLSubs(:, Subs) == LVBusTF(tf)); if isempty(indVLL); indVLL = NaN; end % Position of the high and low voltage within the voltage levels (VL).
        switch TFtypeTF{tf} % Selection of trafo type.
            case 'A' % Autotrafo
                phiW3(tf, (indVLH - 1)*m + Subs) = 1/RphW1STF(tf); phiW3(tf, (indVLL - 1)*m + Subs) = -1/RphW1STF(tf); % Admittances for the series windings (positive from HV to LV bus) [ohm^-1].
                phiW4(tf, (indVLL - 1)*m + Subs) = 1/RphW2CTF(tf); % Admittances for the common windings (positive from LV bus to neutral point) [ohm^-1].
            otherwise % Trafo GSU, GY-GY or Tee.
                phiW1(tf, (indVLH - 1)*m + Subs) = 1/RphW1STF(tf); if isnan(RphW1STF(tf)) && ~strcmp(TFtypeTF{tf}, 'T'); phiW1(tf, (indVLH - 1)*m + Subs) = 0; end % Admittances for the primary windings (positive from HV bus to neutral point) [ohm^-1].
                if ~isnan(indVLL); phiW2(tf, (indVLL - 1)*m + Subs) = 1/RphW2CTF(tf); end %else; if ~strcmp(TFtypeTF{tf}, 'T'); phi2(tf, (indVLL - 1)*m + Subs) = 0; end; end % Admittances for the secondary windings (positive from LV bus to neutral point) [ohm^-1].
        end
    end
end
phiW1 = sparse(phiW1); phiW2 = sparse(phiW2); phiW3 = sparse(phiW3); phiW4 = sparse(phiW4);
LVBusTF_0 = LVBusTF; LVBusTF_0(isnan(LVBusTF_0)) = 0; % Convert NaNs into zeros to compute the effective transformer GIC.
k1 = sparse(~strcmp(TFtypeTF, 'A')./(HVBusTF./LVBusTF_0)); k2 = sparse(strcmp(TFtypeTF, 'A')./(HVBusTF./LVBusTF_0)); % 1/TurnsRatio for full-winding transformers and for autotransformers (nTF x 1) []
phiTF = phiW1 + phiW2.*k1 + phiW3.*(1 - k2) + phiW4.*k2; % Phi admittance matrix to be multiplied by the bus voltages to find the transformer effective GICs. (nTF x nb) [ohm^-1]

Ygb = repmat(Yg, L, 1); % Repeated Yg (nb x 1) [ohm^-1]
BYbn = repmat(IDm, 1, L)*Ybn; % (m x nb) [ohm^-1]

% Calculate M (full and reduced) and decomposition (LU factorization):
M = Ybs*Ybn + (Ybn + Ybb).*Ygb'; % Original design matrix (nb x nb) [ohm^-2]. May contain 0 rows/columns which prevent inversion. These correspond to buses such as the LV bus of SUB1, or the fictitious LV bus of Sw.Sta 7 from Horton et al. 2012.
Mred = M(YbbdiagLogical, YbbdiagLogical); % Removing rows and columns of M corresponding to buses not connecting to others. It's like they don't exist. Mred should no longer contain 0 rows/columns. (s x s) [ohm^-2].
disp(['Rcond Mred = ' num2str(rcond(full(Mred)))]); % Display the Matlab Reciprocal Condition Number for the matrix to be inverted.
decompMred = decomposition(full(Mred), 'lu'); % Creates reusable matrix decompositions (LU, LDL, Cholesky, QR, ...) that enable to solve linear systems (Ax = b or xA = b) more efficiently. For example, after computing dA = decomposition(A) the call dA\b returns the same vector as A\b, but is typically much faster. decomposition objects are well-suited to solving problems that require repeated solutions, since the decomposition of the coefficient matrix does not need to be performed multiple times.

% GIC resolution depending if the geoelectric field is homogeneous or heterogeneous.
if E_homo_hetero == 1 % Cas E homogeni:
    nt = size(E, 1); % Number of time samples.
    E_N = E(:, 2)'; E_E = E(:, 1)'; % Geoelectric field components (1 x nt) [V/km]
    L_N = (111.133 - .56*cosd(Lat' + Lat)).*(Lat' - Lat); % Matrix of North distances between two substations. (nb x nb) [km]
    L_E = (111.5065 - .1872*cosd(Lat' + Lat)).*cosd((Lat' + Lat)/2).*(Lon' - Lon); % Matrix of East distances between two substations. (nb x nb) [km]

    % Compute the GIC for unit electric fields in the North and East directions (E_N_uni(t) = [1 0]; E_E_uni(t) = [0 1]) and then scale with the input electric field:
    G = [sum(repmat(L_N, L, 1).*Ybs(:, 1: m), 2), sum(repmat(L_E, L, 1).*Ybs(:, 1: m), 2)]; % Gamma matrix to compute the current sources J. (nb x 2) [km/ohm] Homogeneous case!
    Jbn_uni = G; Jbnred_uni = Jbn_uni(YbbdiagLogical, :); % Current sources for unit electric fields (nb x 2) [A]. Jbnred is Jbn reduced (after removing rows corresponding to buses not connecting with others) (s x 2) [A].

    Sred_uni = decompMred\Jbnred_uni; % (bus - neutral point voltage)*Rg [V.ohm] (s x 2).
    S_uni = zeros(nb, 2); S_uni(YbbdiagLogical, :) = Sred_uni; % Recovery of removed buses allocating them S_uni = 0 (nb x 2).

    % Calculate GIC to ground in each substation:
    Ig_uni = (BYbn.*Ygb')*S_uni; % Earthward GIC in each substation for unit E field (m x 2) [A].
    if any(abs(sum(Ig_uni)) > 1e-3); disp(['Incongruent total earthing current of ' num2str(abs(sum(Ig_uni))) ' A. Should add to zero.']); crash; end; if any(abs(sum(Ig_uni)) > 1e-5); disp(['Warning! The total flow to earth should add to zero, but it is ' num2str(abs(sum(Ig_uni))) ' A.']); end % Control.
    ag = Ig_uni(:, 1); bg = Ig_uni(:, 2); % a and b scaling constants for the grounding GIC (m x 1) [A/(V/km)].
    Ig = ag.*E_N + bg.*E_E; Ig_round2 = round(Ig, 2); % Grounding GIC at each substation as a function of time. (m x nt) [A].

    % Calculate GIC flowing in transmission lines (positive when flowing from origin substation to destination substation):
    Vbn_uni = Ygb.*S_uni; % Bus - neutral point voltage difference. "Vbus - Vneutral" (nb x 2) [V]. It could be obtained operating per phase as Zbn_ph*Ibn_ph = (3Zbn)*(Ibn/3) = Zbn*Ibn.
    Ind = OriSubsLin + (DesSubsLin - 1)*m; % Ind = sub2ind([m m], OriSubsLin, DesSubsLin); % Index of substations joining lines in L_N and L_E matrices. (n x 1)
    V0bbLin_uni = [L_N(Ind), L_E(Ind)]; % Bus-bus earth voltage difference for each transmission line (n x 2) [V].
    Ilinph_uni = (Vbn_uni(BusOriLin(1: n), :) + Ig_uni(OriSubsLin(1: n), :)./Yg(OriSubsLin(1: n)) - Vbn_uni(BusDesLin(1: n), :) - Ig_uni(DesSubsLin(1: n), :)./Yg(DesSubsLin(1: n)) + V0bbLin_uni)./RLinEq(1: n)/3; Ilinph_uni(nrep(1: n) == 0, :) = NaN; % GIC in transmission lines for unit E field (n x 2) [A/ph]
    al = Ilinph_uni(:, 1); bl = Ilinph_uni(:, 2); % a and b scaling constants for the GIC per phase at the transmission lines (n x 1) [A/ph/(V/km)]
    Ilinph = al.*E_N + bl.*E_E; Ilinph_round2 = round(Ilinph, 2); % GIC at each transmission line as a function of time. (n x nt) [A/ph]

    % Calculate winding and effective GIC flowing in transformers.
    aw1 = phiW1*Vbn_uni(:, 1); bw1 = phiW1*Vbn_uni(:, 2); aw2 = phiW2*Vbn_uni(:, 1); bw2 = phiW2*Vbn_uni(:, 2); awser = phiW3*Vbn_uni(:, 1); bwser = phiW3*Vbn_uni(:, 2); awcom = phiW4*Vbn_uni(:, 1); bwcom = phiW4*Vbn_uni(:, 2); % a and b scaling constants for the GIC at the trafo windings [A/ph/(V/km)]
    Iw1 = aw1.*E_N + bw1.*E_E; Iw2 = aw2.*E_N + bw2.*E_E; Iwser = awser.*E_N + bwser.*E_E; Iwcom = awcom.*E_N + bwcom.*E_E; % GIC at each trafo winding as a function of time. (nTF x nt) [A/ph]
    It_uni_sign = phiTF*Vbn_uni; % Transformer effective GIC for unit E field (nTF x 2) [A/ph].
    at = It_uni_sign(:, 1); bt = It_uni_sign(:, 2); % a and b scaling constants for the effective GIC in each trafo (nTF x 1) [A/ph/(V/km)]
    It = abs(at.*E_N + bt.*E_E); It_round2 = round(It, 2); % Effective GIC at each trafo as a function of time. (nTF x nt) [A/ph]
    
else % Heterogeneous case:
    
    E_3DE = load(fileE_E); % Reading in eastward component of the E field in specified file. (nt x NumGridP)
    E_3DN = load(fileE_N); % Reading in northward component of the E field in specified file. (nt x NumGridP)
    if ~isequal(size(E_3DE), size(E_3DN)); disp('The dimensions of the E field do not match. Check for the size of E_E and E_N in the corresponding input files.'); end % Control
    E_3D = cat(3, E_3DE, E_3DN); % E field at each point of the E grid through time. Warning! E_3D is ordered East in the first layer, North in the 2nd (nt x NumGridP x 2) [V/km].
    LatLon_Egrid = load(fileEgrid); % Reading in coordinates (Lat, Lon) of the E grid in specified file (NumGridP x 2) [º]
    
    nt = size(E_3D, 1); % Number of time samples.
    
    % Calculating latitudes and longitudes of intermediate transmission line points for E field interpolation, and dx (north) and dy (east) distance elements:
    LatIniLin = Lat(OriSubsLin(1: n)); LatFinLin = Lat(DesSubsLin(1: n)); % Lat of the origin and destination of trans. lines (n x 1) [º]
    LonIniLin = Lon(OriSubsLin(1: n)); LonFinLin = Lon(DesSubsLin(1: n)); % Lon of the origin and destination of trans. lines (n x 1) [º]
    ri = [cosd(LatIniLin).*cosd(LonIniLin), cosd(LatIniLin).*sind(LonIniLin), sind(LatIniLin)]; % Vector from Earth center to trans. line origin (n x 3) [km].
    rf = [cosd(LatFinLin).*cosd(LonFinLin), cosd(LatFinLin).*sind(LonFinLin), sind(LatFinLin)]; % Vector from Earth center to trans. line destination (n x 3) [km].

    AngLin = acosd(dot(ri, rf, 2)); % Angle subtended by each line as seen from the center of the Earth (maximum circle) (n x 1) [º]
    NPInt = floor(AngLin/da) + 1; MaxNPInt = max(NPInt); % Number of intermediate points for interpolation in each line.
    LonIniLin3D = permute(LonIniLin, [3 2 1]); % (1 x 1 x n)
    LatPIntNord = NaN(MaxNPInt, 1, n);
    for tlin = 1: n
        LatPIntNord(1: NPInt(tlin), 1, tlin) = LatIniLin(tlin) + da/2: da: LatIniLin(tlin) + da*NPInt(tlin); % Latitude of intermediate points in the North direction (MaxNPInt x 1 x n) [].
    end
    rPIntNord = [cosd(LatPIntNord).*cosd(LonIniLin3D), cosd(LatPIntNord).*sind(LonIniLin3D), sind(LatPIntNord)]; % Unit vectors of intermediate line points in the North direction (MaxNPInt x 3 x n) [].
    cosAzi = (LatFinLin - LatIniLin)./AngLin; % Approx. cosine of the trans. line azimuth (respect to North). (n x 1) []
    sinAzi = sqrt(1 - cosAzi.^2); sinAzi(LonFinLin < LonIniLin) = -sinAzi(LonFinLin < LonIniLin); % Approx. sine of line azimuth. (n x 1) []
    Azi = atan2d(sinAzi, cosAzi); % Azimuth of trans. line resp. North. (n x 1) [º]
    Rc_m = 111.133 - .56*cosd(LatIniLin + LatFinLin); Rc_z = 111.5065 - .1872*cosd(LatIniLin + LatFinLin); % pi/180 times curvature radius of Earth in the meridional and zonal directions. Equivalently, length of 1º in the meridional and zonal directions. (n x 1) [km]
    dx = Rc_m*da.*cosAzi; dy = Rc_z*da.*sinAzi; % North and East projection of the element of line among intermediate points (n x 1) [km]. It is assumed constant through all the elements, though it is not, especially at high latitudes.
    rPInt = NaN(MaxNPInt, 3, n); % Will be (n x MaxNPInt x 3).
    for tlin = 1: n % Loop to find unit vectors of the intermediate points between trans. lines
        Vec = rPIntNord(1: NPInt(tlin), :, tlin); % (NPInt(tlin) x 3)
        eixrep = repmat(ri(tlin, :), NPInt(tlin), 1); % (NPInt(tlin) x 3)
        rPInt(1: NPInt(tlin), :, tlin) = repmat(dot(Vec, eixrep, 2), 1, 3).*eixrep + sind(-Azi(tlin))*cross(eixrep, Vec, 2) + cosd(-Azi(tlin))*cross(cross(eixrep, Vec, 2), eixrep, 2);
    end
    rPInt = permute(rPInt, [1 3 2]); % Unit vectors of the intermediate points between trans. lines (MaxNPInt x n x 3) [].
    [LonPInt, LatPInt, ~] = cart2sph(rPInt(:, :, 1), rPInt(:, :, 2), rPInt(:, :, 3)); LonPInt = LonPInt*180/pi; LatPInt = LatPInt*180/pi; % Latitude, Longitude of intermediate line points (MaxNPInt x n) [º]
    LatPInt_finit = LatPInt(isfinite(LatPInt)); LonPInt_finit = LonPInt(isfinite(LonPInt)); % Latitude, Longitude of intermediate line points in a row (nz x n) [º]

    % Interpolating the geoelectric field: 
    nz = length(LatPInt_finit); % Number of geological zones.
    MatInd = LatPInt; MatInd(isfinite(MatInd)) = 1: nz; IndIni = MatInd(1, :); IndFin = IndIni + NPInt' - 1;
    Ex_i = NaN(nz, nt); Ey_i = Ex_i; % x (North) and y (East) components of the interpolated geoelectric field [V/km].
    for t = 1: nt % Loop through time
        if round(t/100) == t/100; disp(['t = ', num2str(t)]); end
        FEx = scatteredInterpolant(LatLon_Egrid, E_3D(t, :, 2)', 'linear', 'nearest'); % Bi-linear interpolating object for Ex component (Nord). Off-grid points are interpolated by nearest-neighbour.
        FEy = scatteredInterpolant(LatLon_Egrid, E_3D(t, :, 1)', 'linear', 'nearest'); % Bi-linear interpolating object for Ey component (Est).  Off-grid points are interpolated by nearest-neighbour.
        Ex_i(:, t) = FEx(LatPInt_finit, LonPInt_finit); % x (North) component of the interpolated geoelectric field [V/km].
        Ey_i(:, t) = FEy(LatPInt_finit, LonPInt_finit); % y (East)  component of the interpolated geoelectric field [V/km].
    end
    
    % Calculating Gamma, the matrix multiplying E to find the current sources J (J = G*E):
    frac = AngLin/da - (NPInt - 1); % Fractionary part at the end of each line.
    V0bbLin = zeros(n, nt);
    G = zeros(nb, 2*nz); % Gamma matrix to compute the current sources J. (nb x 2nz) [km/ohm]
    for tlin = 1: n
        BusOriLintlin = BusOriLin(tlin); BusDesLintlin = BusDesLin(tlin);
        if ~any((BusOriLin(1: tlin - 1) == BusOriLintlin).*(BusDesLin(1: tlin - 1) == BusDesLintlin) + (BusOriLin(1: tlin - 1) == BusDesLintlin).*(BusDesLin(1: tlin - 1) == BusOriLintlin))
            G(BusOriLintlin, IndIni(tlin): IndFin(tlin) - 1) = dx(tlin)*Ybb(BusOriLintlin, BusDesLintlin); G(BusOriLintlin, IndFin(tlin)) = dx(tlin)*Ybb(BusOriLintlin, BusDesLintlin)*frac(tlin);
            G(BusOriLintlin, nz + (IndIni(tlin): IndFin(tlin) - 1)) = dy(tlin)*Ybb(BusOriLintlin, BusDesLintlin); G(BusOriLintlin, nz + IndFin(tlin)) = dy(tlin)*Ybb(BusOriLintlin, BusDesLintlin)*frac(tlin);
            G(BusDesLintlin, IndIni(tlin): IndFin(tlin)) = -G(BusOriLintlin, IndIni(tlin): IndFin(tlin));
            G(BusDesLintlin, nz + (IndIni(tlin): IndFin(tlin))) = -G(BusOriLintlin, nz + (IndIni(tlin): IndFin(tlin)));
        end
        V0bbLin(tlin, :) = dx(tlin)*(sum(Ex_i(IndIni(tlin): IndFin(tlin) - 1, :), 1) + Ex_i(IndFin(tlin), :)*frac(tlin)) + dy(tlin)*(sum(Ey_i(IndIni(tlin): IndFin(tlin) - 1, :), 1) + Ey_i(IndFin(tlin), :)*frac(tlin)); % Voltage difference among the buses joining a given trans. line. (n x 1) [V]
    end
    G = sparse(G);

    % Calculating the bus current sources J and inversion:
    Jbn = G*[Ex_i; Ey_i]; Jbnred = Jbn(YbbdiagLogical, :); % Current sources (nb x nt) [A]. Jbnred is Jbn reduced (after removing rows corresponding to buses not connecting with others).
    Sred = decompMred\Jbnred; % (bus - neutral point voltage)*Rg [V.ohm] (s x nt).
    S = zeros(nb, nt); S(YbbdiagLogical, :) = Sred; % Recovery of removed buses allocating them S = 0 (nb x nt)

    % Calculate GIC to ground in each substation:
    Ig = (BYbn.*Ygb')*S; %Ig_round2 = round(Ig, 2); % Earthward GIC in each substation (m x nt) [A]
    if any(abs(sum(Ig)) > 1e-3); disp(['Incongruent total earthing current of ' num2str(abs(sum(Ig))) ' A. Should add to zero.']); crash; end; if any(abs(sum(Ig)) > 1e-5); disp(['Warning! The total flow to earth should add to zero, but it is ' num2str(abs(sum(Ig))) ' A.']); end % Control.

    Vbn = Ygb.*S; % Bus - neutral point voltage difference. "Vbus - Vneutral" (nb x nt) [V]. It could be obtained operating per phase as Zbn_ph*Ibn_ph = (3Zbn)*(Ibn/3) = Zbn*Ibn.

    % Calculate GIC flowing in transmission lines (positive when flowing from origin substation to destination substation):
    Ilinph = (Vbn(BusOriLin(1: n), :) + Ig(OriSubsLin(1: n), :)./Yg(OriSubsLin(1: n)) - Vbn(BusDesLin(1: n), :) - Ig(DesSubsLin(1: n), :)./Yg(DesSubsLin(1: n)) + V0bbLin)./RLinEq(1: n)/3; Ilinph(nrep(1: n) == 0, :) = NaN; % GIC in transmission lines (n x nt) [A/ph]

    % Calculate winding and effective GIC flowing in transformers.
    Iw1 = phiW1*Vbn; Iw2 = phiW2*Vbn; Iwser = phiW3*Vbn; Iwcom = phiW4*Vbn; % Transformer winding GIC (nTF x nt) [A/ph]. % 0.0192 s
    It = abs(phiTF*Vbn); % Transformer effective GIC (nTF x nt) [A/ph].
end
toc

% Figures and video:
if ShowFigures

    if ~isempty(BaseMapFile) % If a base map file has been specified ...
        if BaseMapFileDataType == 1 % If the base map contains (Lat, Lon) data ...
            LatLonMap = load(BaseMapFile); % Reading-in map.
            [Y_UTMMap , X_UTMMap] = deg2utm_zone(LatLonMap(:, 1), LatLonMap(:, 2), ForceUTMZoneTo); % UTM coordinates of map.
            UTM_Map = [Y_UTMMap, X_UTMMap]/1000; % Change order.
        else
            UTM_Map = load(BaseMapFile)/1000; % UTM data of the map boundaries. Must be given in a common UTM zone = ForceUTMZoneTo [km]
        end
    end

    [Y_UTM0, X_UTM0] = deg2utm_zone(repmat(Lat, L, 1), repmat(Lon, L, 1), ForceUTMZoneTo); XY_UTM = [X_UTM0, Y_UTM0]/1000; %XY_UTM = [X_UTM0 - 4.4e6, Y_UTM0 - 5e5]/1000; % X (North), Y (East) UTM coordinates of the buses (nb x 2) [km]
    CoordBus = [XY_UTM(:, 2), XY_UTM(:, 1)]; % Change the order: Y, X (East, North). (nb x 2) [km]
    VLNet = flipud(unique(VLSubs(isfinite(VLSubs)))); % Network voltage levels from upper to lower.
    CodColors = [255 102 102; 51 204 255; 0 0 0]/255; CodColors = repmat(CodColors, ceil(length(VLNet)/size(CodColors, 1)), 1); % Color code for each voltage level (for representation of trans. lines), from upper to lower voltage.

    % Map representing the maximum grounding absolute GIC in each substation by circles with radii proportional to GIC during an event:
    Igmax = max(abs(Ig), [], 2); % Max. grounding GIC at each substation throughout the event. (m x 1) [A]
    Iemaxtot = max(Igmax); % Max. grounding GIC through substations and time. (1 x 1) [A]
    figure; plot(UTM_Map(:, 1), UTM_Map(:, 2), 'k'); hold on; axis equal
    xlabel('Easting (km)', 'FontSize', 15); ylabel('Northing (km)', 'FontSize', 15); %xlim([-600 600]); ylim([-500 500]);
    for tlin = 1: n % Loop through trans. lines to plot them.
        plot([CoordBus(OriSubsLin(tlin), 1); CoordBus(DesSubsLin(tlin), 1)], [CoordBus(OriSubsLin(tlin), 2); CoordBus(DesSubsLin(tlin), 2)], 'Color', CodColors(VLNet == VTLin(tlin), :))
    end
    scale = 78.2; % Scale [A]. This GIC will be assigned a circle of 50 units radius.
    radius = Igmax*50/scale; % Circle radius.
    for i = 1: m % Loop through substations to plot the circle proportional to the grounding GIC.
        if radius(i) > 0
            plot(XY_UTM(i, 2), XY_UTM(i, 1), 'ob', 'MarkerSize', radius(i));
        end
    end
    xl = xlim; yl = ylim;
    plot(xl(1) + 950, yl(1) + 150, 'ok', 'MarkerSize', 50*50/scale); text(xl(1) + 1030, yl(1) + 150, '50 A'); % Draw the reference circle.
    title(['Max. absolute GIC to ground = ', num2str(round(Iemaxtot, 1)), ' A']);

    % Video of the time evolution of the grounding GIC during the event:
    if ~isempty(SaveVideoAs)
        radius = Ig*50/scale; % Circle radius.
        tIniVideo = 1; tFinPeli = nt; % First and last time indices for video frames.
        tcIniVideo = datenum(datetime_video_start, 'yyyy-mm-dd HH:MM');
        MT(tFinPeli - tIniVideo + 1) = struct('cdata', [], 'colormap', []); % Initializing frames.
        figure;
        for t = tIniVideo: tFinPeli % Loop through time to generate the frames:
            yyyymmdd_ = datestr(tcIniVideo + (t - tIniVideo)/60/24, 29);
            hhmmss_ = datestr(tcIniVideo + (t - tIniVideo)/60/24, 15);
            plot(UTM_Map(:, 1), UTM_Map(:, 2), 'k'); hold on; axis equal; xlabel('Easting (km)', 'FontSize', 15); ylabel('Northing (km)', 'FontSize', 15); %xlim([-600 600]); ylim([-500 500]);
            for tlin = 1: n % Plot the lines with a different color for each AC voltage:
                plot([CoordBus(OriSubsLin(tlin), 1); CoordBus(DesSubsLin(tlin), 1)], [CoordBus(OriSubsLin(tlin), 2); CoordBus(DesSubsLin(tlin), 2)], 'Color', CodColors(VLNet == VTLin(tlin), :))
            end
            for i = 1: m % Plot the circles proportional to the grounding GIC.
                if radius(i, t) > 0
                    plot(XY_UTM(i, 2), XY_UTM(i, 1), 'or', 'MarkerSize', radius(i, t));
                end
                if radius(i, t) < 0
                    plot(XY_UTM(i, 2), XY_UTM(i, 1), 'ob', 'MarkerSize', -radius(i, t));
                end
            end
            if t == tIniVideo % Add the label with date and time:
                han =  annotation('TextBox', [0.2 0.13 .1 .1], 'String', {yyyymmdd_; ['  ', hhmmss_, ' UT']}, 'LineStyle', 'none', 'FontSize', 10);
            else
                delete(han)
                han =  annotation('TextBox', [0.2 0.13 .1 .1], 'String', {yyyymmdd_; ['  ', hhmmss_, ' UT']}, 'LineStyle', 'none', 'FontSize', 10);
            end
            plot(xl(2) - 210, yl(1) + 150, 'ok', 'MarkerSize', 50*50/scale); text(xl(2) - 120, yl(1) + 150, '50 A'); %Draw the reference circle.
            title('GIC(t) to ground');
            MT(t - tIniVideo + 1) = getframe;
            hold off
        end
        % Once frames are available, generate the video:
        v = VideoWriter(SaveVideoAs);
        v.FrameRate = 5; % Frames/sec
        v.Quality = 100;
        open(v)
        writeVideo(v, MT)
        close(v)
    end

    % Max. GIC per phase in trans. lines during the event:
    IniLin = NaN(n, 2); FinLin = IniLin;
    for tlin = 1: n % Passo per a cada línia real.
        IniLin(tlin, :) = XY_UTM(BusOriLin(tlin), :); % X(N), Y(E) coordinates of the line origin [km].
        FinLin(tlin, :) = XY_UTM(BusDesLin(tlin), :); % X(N), Y(E) coordinates of the line destination [km].
    end
    Iphasemax = max(abs(Ilinph), [], 2); % Max. GIC/phase of a given line throughout the event. [A/ph] (n x 1)
    Ifasemaxtot = max(Iphasemax); % Absolute maximum throughout all the lines. [A/ph] (1 x 1)
    figure; plot(UTM_Map(:, 1), UTM_Map(:, 2), 'k'); hold on; axis equal
    xlabel('Easting (km)', 'FontSize', 15); ylabel('Northing (km)', 'FontSize', 15); %xlim([-600 600]); ylim([-500 500]);
    ColorMat = colormap('jet'); % Select one of the default Matlab colormaps (jet, parula, winter, etc.)
    AmplLin = VTLin/220 + .1; % Width of trans. lines as a function of its AC voltage [dots].
    for tlin = 1: n % Loop through trans. lines to set its color in terms of the flowing GIC:
        if Iphasemax(tlin) ~= 0; plot([IniLin(tlin, 2) FinLin(tlin, 2)], [IniLin(tlin, 1) FinLin(tlin, 1)], 'LineWidth', AmplLin(tlin), 'color', ColorMat(ceil(size(ColorMat, 1)/Ifasemaxtot*Iphasemax(tlin)), :)); end
    end
    for i = 1: m % Add the substations:
        plot(XY_UTM(i, 2), XY_UTM(i, 1), 'o', 'MarkerEdgeColor', 'k', 'MarkerFaceColor', 'k', 'MarkerSize', 2);
    end
    c = colorbar('Ticks', 0: .2: 1, 'TickLabels', round(0: 0.2*Ifasemaxtot: Ifasemaxtot)); c.Label.String = 'A/ph'; c.Label.Rotation = 0; c.FontSize = 15;
    title(['Max. absolute GIC in transmission lines = ', num2str(round(Ifasemaxtot, 1)), ' A/phase']);

    % Bar figure: max. GIC/phase flowing in each trafo (through any of its windings) throughout the event.
    HVLTF = HVBusTF(isfinite(HVBusTF)); if length(HVLTF) ~= nTF; crash; end  % High voltage level of each trafo in the network [kVAC] (nTF x 1).
    HVLTFSort = flipud(unique(HVLTF(HVLTF > 0))); % High voltage level of trafos in the network, sorted in descending order [kVAC] (? x 1).
    TFnum = 1: nTF;
    Iwmax = max([abs(Iw1) abs(Iw2) abs(Iwser) abs(Iwcom)], [], 2); % Max absolute GIC per transformer (throughout all its windings) [A/ph] (nTF x 1).
    CodColors2 = 'rbgk'; CodColors2 = repmat(CodColors2, ceil(length(HVLTFSort)/length(CodColors2)), 1); % Color code for each voltage level (for representation of trans. lines), from upper to lower voltage.
    figure; bar(TFnum, 0*TFnum); hold on
    for HVLpos = 1: length(HVLTFSort) % Loop through the highest voltage levels of each trafo to plot bars graph.
        bar(TFnum(HVLTF == HVLTFSort(HVLpos)), Iwmax(HVLTF == HVLTFSort(HVLpos)), 0.9, CodColors2(HVLpos));
    end
    xlabel('# Trafo', 'FontSize', 15); ylabel('GIC (A/phase)', 'FontSize', 15);
    title('Peak winding GIC flow throughout all the windings of each transformer', 'FontSize', 15);

    % GIC flowing in a (user-defined) line vs. time (does not account for multiple lines!).
    nlinstr = inputdlg({['Insert the line number for which you want to plot the GIC (press Enter if none). Lines range from 1 to ', num2str(n), ':']});
    nlin = str2double(nlinstr);
    if nlin >= 0
        figure;
        titol=strcat({'GIC Line '},nlinstr);
        tm = 60; % Sampling time [s].
        plot((0:size(Ilinph, 2)-1)/3600*tm, 3*Ilinph(nlin,:), 'b');
        xlim([0 size(Ilinph, 2)/3600*tm]);
        title(titol,'FontSize',14);
        set(gca,'YGrid','on','units','pixels','Position',[100,100,1450,450],'units','points','FontSize',14)
        ylabel('GIC [A/lin]','FontSize',14);
        xlabel('Time [h]','FontSize',14);    
    end
end